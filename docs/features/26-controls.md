# Feature 26: UI Controls

## Overview

Implement the UI control classes that render content inside Window containers, including BufferControl for editable text and FormattedTextControl for static formatted text.

## Python Prompt Toolkit Reference

**Source:** `/Users/brandon/src/python-prompt-toolkit/src/prompt_toolkit/layout/controls.py`

## Public API

### UIContent Class

```csharp
namespace Stroke.Layout;

/// <summary>
/// Content generated by a user control. This content consists of a list of lines.
/// </summary>
public sealed class UIContent
{
    /// <summary>
    /// Creates UIContent.
    /// </summary>
    /// <param name="getLine">Callable that takes a line number and returns formatted text.</param>
    /// <param name="lineCount">The number of lines.</param>
    /// <param name="cursorPosition">Cursor position as a Point.</param>
    /// <param name="menuPosition">Menu position as a Point.</param>
    /// <param name="showCursor">True to make cursor visible.</param>
    public UIContent(
        Func<int, StyleAndTextTuples>? getLine = null,
        int lineCount = 0,
        Point? cursorPosition = null,
        Point? menuPosition = null,
        bool showCursor = true);

    /// <summary>
    /// Get a line of content.
    /// </summary>
    public Func<int, StyleAndTextTuples> GetLine { get; }

    /// <summary>
    /// The number of lines.
    /// </summary>
    public int LineCount { get; }

    /// <summary>
    /// The cursor position.
    /// </summary>
    public Point CursorPosition { get; }

    /// <summary>
    /// The menu position.
    /// </summary>
    public Point? MenuPosition { get; }

    /// <summary>
    /// True if cursor should be shown.
    /// </summary>
    public bool ShowCursor { get; }

    /// <summary>
    /// Get the line at the given index.
    /// </summary>
    public StyleAndTextTuples this[int lineno] { get; }

    /// <summary>
    /// Return the height that a given line would need if rendered at the given width.
    /// </summary>
    /// <param name="lineno">The line number.</param>
    /// <param name="width">The available width.</param>
    /// <param name="getLinePrefix">Optional line prefix getter.</param>
    /// <param name="sliceStop">Optional slice stop for partial calculation.</param>
    public int GetHeightForLine(
        int lineno,
        int width,
        Func<int, int, FormattedText>? getLinePrefix = null,
        int? sliceStop = null);
}
```

### IUIControl Interface

```csharp
namespace Stroke.Layout;

/// <summary>
/// Base interface for all user interface controls.
/// </summary>
public interface IUIControl
{
    /// <summary>
    /// Reset the control state.
    /// </summary>
    void Reset();

    /// <summary>
    /// Return the preferred width, or null for no preference.
    /// </summary>
    int? PreferredWidth(int maxAvailableWidth);

    /// <summary>
    /// Return the preferred height, or null for no preference.
    /// </summary>
    int? PreferredHeight(
        int width,
        int maxAvailableHeight,
        bool wrapLines,
        Func<int, int, FormattedText>? getLinePrefix);

    /// <summary>
    /// Tell whether this control is focusable.
    /// </summary>
    bool IsFocusable();

    /// <summary>
    /// Generate the content for this control.
    /// </summary>
    UIContent CreateContent(int width, int height);

    /// <summary>
    /// Handle mouse events.
    /// Returns NotImplemented if not handled.
    /// </summary>
    NotImplementedOrNone MouseHandler(MouseEvent mouseEvent);

    /// <summary>
    /// Request to move the cursor down (for scrolling).
    /// </summary>
    void MoveCursorDown();

    /// <summary>
    /// Request to move the cursor up (for scrolling).
    /// </summary>
    void MoveCursorUp();

    /// <summary>
    /// Return key bindings specific to this control.
    /// </summary>
    IKeyBindingsBase? GetKeyBindings();

    /// <summary>
    /// Return events that should trigger a redraw.
    /// </summary>
    IEnumerable<IEvent<object>> GetInvalidateEvents();
}
```

### FormattedTextControl Class

```csharp
namespace Stroke.Layout;

/// <summary>
/// Control that displays formatted text.
/// </summary>
public sealed class FormattedTextControl : IUIControl
{
    /// <summary>
    /// Creates a FormattedTextControl.
    /// </summary>
    /// <param name="text">Text or formatted text to display.</param>
    /// <param name="style">Style string applied to content.</param>
    /// <param name="focusable">True if focusable.</param>
    /// <param name="keyBindings">Key bindings for this control.</param>
    /// <param name="showCursor">True to show cursor.</param>
    /// <param name="modal">True if modal.</param>
    /// <param name="getCursorPosition">Callable that returns cursor position.</param>
    public FormattedTextControl(
        object text = "",
        string style = "",
        object? focusable = null,
        IKeyBindingsBase? keyBindings = null,
        bool showCursor = true,
        bool modal = false,
        Func<Point?>? getCursorPosition = null);

    /// <summary>
    /// The text content.
    /// </summary>
    public object Text { get; set; }

    /// <summary>
    /// The style string.
    /// </summary>
    public string Style { get; set; }

    /// <summary>
    /// Focusable filter.
    /// </summary>
    public IFilter Focusable { get; }

    // IUIControl implementation...
}
```

### DummyControl Class

```csharp
namespace Stroke.Layout;

/// <summary>
/// A dummy control that doesn't paint any content.
/// Useful for filling a Window.
/// </summary>
public sealed class DummyControl : IUIControl
{
    // IUIControl implementation with empty content...
}
```

### BufferControl Class

```csharp
namespace Stroke.Layout;

/// <summary>
/// Control for visualizing the content of a Buffer.
/// </summary>
public sealed class BufferControl : IUIControl
{
    /// <summary>
    /// Creates a BufferControl.
    /// </summary>
    /// <param name="buffer">The Buffer to display.</param>
    /// <param name="inputProcessors">List of input processors.</param>
    /// <param name="includeDefaultInputProcessors">Include default processors.</param>
    /// <param name="lexer">Lexer for syntax highlighting.</param>
    /// <param name="previewSearch">Show search while typing.</param>
    /// <param name="focusable">True if focusable.</param>
    /// <param name="searchBufferControl">Associated search buffer control.</param>
    /// <param name="menuPosition">Callable that returns menu position.</param>
    /// <param name="focusOnClick">Focus when clicked.</param>
    /// <param name="keyBindings">Key bindings for this control.</param>
    public BufferControl(
        Buffer? buffer = null,
        IReadOnlyList<IProcessor>? inputProcessors = null,
        bool includeDefaultInputProcessors = true,
        ILexer? lexer = null,
        object? previewSearch = null,
        object? focusable = null,
        object? searchBufferControl = null,
        Func<int?>? menuPosition = null,
        object? focusOnClick = null,
        IKeyBindingsBase? keyBindings = null);

    /// <summary>
    /// The buffer being displayed.
    /// </summary>
    public Buffer Buffer { get; }

    /// <summary>
    /// The lexer for syntax highlighting.
    /// </summary>
    public ILexer Lexer { get; set; }

    /// <summary>
    /// The search buffer control.
    /// </summary>
    public SearchBufferControl? SearchBufferControl { get; }

    /// <summary>
    /// The search buffer.
    /// </summary>
    public Buffer? SearchBuffer { get; }

    /// <summary>
    /// The search state.
    /// </summary>
    public SearchState SearchState { get; }

    // IUIControl implementation...
}
```

### SearchBufferControl Class

```csharp
namespace Stroke.Layout;

/// <summary>
/// BufferControl specifically for search input.
/// </summary>
public sealed class SearchBufferControl : BufferControl
{
    /// <summary>
    /// Creates a SearchBufferControl.
    /// </summary>
    /// <param name="buffer">The search buffer.</param>
    /// <param name="inputProcessors">Input processors.</param>
    /// <param name="lexer">Lexer for highlighting.</param>
    /// <param name="focusOnClick">Focus when clicked.</param>
    public SearchBufferControl(
        Buffer? buffer = null,
        IReadOnlyList<IProcessor>? inputProcessors = null,
        ILexer? lexer = null,
        object? focusOnClick = null);

    /// <summary>
    /// The search state for this search control.
    /// </summary>
    public SearchState SearcherSearchState { get; }
}
```

## Project Structure

```
src/Stroke/
└── Layout/
    ├── UIContent.cs
    ├── IUIControl.cs
    ├── FormattedTextControl.cs
    ├── DummyControl.cs
    ├── BufferControl.cs
    └── SearchBufferControl.cs
tests/Stroke.Tests/
└── Layout/
    ├── UIContentTests.cs
    ├── FormattedTextControlTests.cs
    ├── DummyControlTests.cs
    └── BufferControlTests.cs
```

## Implementation Notes

### UIContent Line Height Calculation

For wrapped lines, height is calculated by:
1. Get the line text width
2. If there's a line prefix, add its width
3. Divide by available width to get number of wrapped rows
4. Cache results per render for performance

### FormattedTextControl Mouse Handling

Mouse handling in FormattedTextControl:
1. Split fragments into lines
2. Find the fragment at the click position
3. If fragment has a handler (3-tuple), call it
4. Return NotImplemented if no handler

### BufferControl Input Processors

Default input processors:
- `HighlightSearchProcessor` - Highlight search matches
- `HighlightIncrementalSearchProcessor` - Highlight incremental search
- `HighlightSelectionProcessor` - Highlight selection
- `DisplayMultipleCursors` - Display multiple cursors

### BufferControl Lexer Integration

The lexer is called to get styled fragments for each line:
1. Create a cache key from document and width
2. Call lexer to get fragments
3. Cache results (up to 8 documents)

### Double-Click Word Selection

BufferControl tracks click timestamps:
- Single click: move cursor
- Double-click: select word
- Triple-click: select line

### Cursor Position Fragment

Special fragment `[SetCursorPosition]` can be used in FormattedTextControl to specify cursor position dynamically.

## Dependencies

- `Stroke.Core.Buffer` (Feature 02) - Buffer class
- `Stroke.Core.FormattedText` (Feature 13) - Formatted text
- `Stroke.Input.MouseEvent` (Feature 17) - Mouse events
- `Stroke.Lexers` (Feature 45) - Lexer system
- `Stroke.Layout.Processors` (Feature 29) - Input processors
- `Stroke.KeyBinding` (Feature 19) - Key bindings

## Implementation Tasks

1. Implement `UIContent` class
2. Implement `IUIControl` interface
3. Implement `FormattedTextControl` class
4. Implement `DummyControl` class
5. Implement `BufferControl` class with lexer integration
6. Implement `SearchBufferControl` class
7. Implement mouse handling
8. Implement double-click word selection
9. Write comprehensive unit tests

## Acceptance Criteria

- [ ] All control types match Python Prompt Toolkit semantics
- [ ] UIContent height calculation works correctly
- [ ] BufferControl displays buffer content correctly
- [ ] FormattedTextControl displays formatted text correctly
- [ ] Mouse handling works correctly
- [ ] Lexer integration works correctly
- [ ] Unit tests achieve 80% coverage
