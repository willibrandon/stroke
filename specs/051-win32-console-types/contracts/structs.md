# API Contract: Win32 Console Structs

**Feature**: 051-win32-console-types
**Namespace**: `Stroke.Input.Windows.Win32Types`
**Date**: 2026-02-02

## COORD

```csharp
/// <summary>
/// Represents a coordinate in the console screen buffer.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows COORD structure. Used for cursor positioning,
/// buffer sizes, and mouse coordinates.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct Coord : IEquatable<Coord>
{
    /// <summary>Horizontal position (column, 0-based).</summary>
    public readonly short X;

    /// <summary>Vertical position (row, 0-based).</summary>
    public readonly short Y;

    /// <summary>
    /// Initializes a new <see cref="Coord"/> with the specified coordinates.
    /// </summary>
    public Coord(short x, short y);

    // IEquatable<Coord> implementation
    public bool Equals(Coord other);
    public override bool Equals(object? obj);
    public override int GetHashCode();
    public static bool operator ==(Coord left, Coord right);
    public static bool operator !=(Coord left, Coord right);
    public override string ToString();
}
```

**Size**: 4 bytes

---

## SmallRect

```csharp
/// <summary>
/// Represents a rectangular region in the console screen buffer.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows SMALL_RECT structure. Coordinates are inclusive.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct SmallRect : IEquatable<SmallRect>
{
    /// <summary>Left edge (inclusive, 0-based column).</summary>
    public readonly short Left;

    /// <summary>Top edge (inclusive, 0-based row).</summary>
    public readonly short Top;

    /// <summary>Right edge (inclusive, 0-based column).</summary>
    public readonly short Right;

    /// <summary>Bottom edge (inclusive, 0-based row).</summary>
    public readonly short Bottom;

    /// <summary>
    /// Initializes a new <see cref="SmallRect"/> with the specified edges.
    /// </summary>
    public SmallRect(short left, short top, short right, short bottom);

    /// <summary>Gets the width of the rectangle.</summary>
    public short Width { get; }

    /// <summary>Gets the height of the rectangle.</summary>
    public short Height { get; }

    // IEquatable<SmallRect> implementation
    public bool Equals(SmallRect other);
    public override bool Equals(object? obj);
    public override int GetHashCode();
    public static bool operator ==(SmallRect left, SmallRect right);
    public static bool operator !=(SmallRect left, SmallRect right);
    public override string ToString();
}
```

**Size**: 8 bytes

---

## KeyEventRecord

```csharp
/// <summary>
/// Describes a keyboard input event in a console input record.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows KEY_EVENT_RECORD structure.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct KeyEventRecord
{
    /// <summary>
    /// Non-zero if the key is pressed; zero if released.
    /// </summary>
    public readonly int KeyDown;

    /// <summary>
    /// Number of times the keystroke is repeated.
    /// </summary>
    public readonly ushort RepeatCount;

    /// <summary>
    /// Virtual-key code (Windows VK_* values).
    /// </summary>
    public readonly ushort VirtualKeyCode;

    /// <summary>
    /// Hardware scan code for the key.
    /// </summary>
    public readonly ushort VirtualScanCode;

    /// <summary>
    /// Unicode character generated by the key press.
    /// </summary>
    /// <remarks>
    /// This is a simplification of the native UNICODE_OR_ASCII union.
    /// .NET is natively Unicode, so the ASCII variant is omitted.
    /// </remarks>
    public readonly char UnicodeChar;

    /// <summary>
    /// State of control keys and toggle states.
    /// </summary>
    public readonly ControlKeyState ControlKeyState;

    /// <summary>
    /// Gets whether the key is pressed (vs. released).
    /// </summary>
    public bool IsKeyDown { get; }
}
```

**Size**: 16 bytes

---

## MouseEventRecord

```csharp
/// <summary>
/// Describes a mouse input event in a console input record.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows MOUSE_EVENT_RECORD structure.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct MouseEventRecord
{
    /// <summary>
    /// Mouse position in screen buffer coordinates.
    /// </summary>
    public readonly Coord MousePosition;

    /// <summary>
    /// State of mouse buttons.
    /// </summary>
    public readonly MouseButtonState ButtonState;

    /// <summary>
    /// State of control keys.
    /// </summary>
    public readonly ControlKeyState ControlKeyState;

    /// <summary>
    /// Type of mouse event.
    /// </summary>
    public readonly MouseEventFlags EventFlags;
}
```

**Size**: 16 bytes

---

## WindowBufferSizeRecord

```csharp
/// <summary>
/// Describes a console screen buffer resize event.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows WINDOW_BUFFER_SIZE_RECORD structure.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct WindowBufferSizeRecord
{
    /// <summary>
    /// New size of the screen buffer.
    /// </summary>
    public readonly Coord Size;
}
```

**Size**: 4 bytes

---

## MenuEventRecord

```csharp
/// <summary>
/// Describes a menu event in a console input record.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows MENU_EVENT_RECORD structure.
/// This event type is reserved by Windows and should be ignored by applications.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct MenuEventRecord
{
    /// <summary>
    /// Menu command identifier (reserved).
    /// </summary>
    public readonly uint CommandId;
}
```

**Size**: 4 bytes

---

## FocusEventRecord

```csharp
/// <summary>
/// Describes a focus change event in a console input record.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows FOCUS_EVENT_RECORD structure.
/// This event type is reserved by Windows and should be ignored by applications.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct FocusEventRecord
{
    /// <summary>
    /// Non-zero if the console gained focus; zero if lost.
    /// </summary>
    public readonly int SetFocus;

    /// <summary>
    /// Gets whether the console gained focus.
    /// </summary>
    public bool HasFocus { get; }
}
```

**Size**: 4 bytes

---

## InputRecord

```csharp
/// <summary>
/// Describes an input event in the console input buffer.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows INPUT_RECORD structure. This is a discriminated union
/// where <see cref="EventType"/> indicates which event field is valid.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Explicit, Size = 20)]
public readonly struct InputRecord
{
    /// <summary>
    /// Type of input event. Determines which union field is valid.
    /// </summary>
    [FieldOffset(0)]
    public readonly EventType EventType;

    /// <summary>
    /// Keyboard event data. Valid when <see cref="EventType"/> is <see cref="Win32Types.EventType.KeyEvent"/>.
    /// </summary>
    [FieldOffset(4)]
    public readonly KeyEventRecord KeyEvent;

    /// <summary>
    /// Mouse event data. Valid when <see cref="EventType"/> is <see cref="Win32Types.EventType.MouseEvent"/>.
    /// </summary>
    [FieldOffset(4)]
    public readonly MouseEventRecord MouseEvent;

    /// <summary>
    /// Window resize event data. Valid when <see cref="EventType"/> is <see cref="Win32Types.EventType.WindowBufferSizeEvent"/>.
    /// </summary>
    [FieldOffset(4)]
    public readonly WindowBufferSizeRecord WindowBufferSizeEvent;

    /// <summary>
    /// Menu event data. Valid when <see cref="EventType"/> is <see cref="Win32Types.EventType.MenuEvent"/>.
    /// </summary>
    [FieldOffset(4)]
    public readonly MenuEventRecord MenuEvent;

    /// <summary>
    /// Focus event data. Valid when <see cref="EventType"/> is <see cref="Win32Types.EventType.FocusEvent"/>.
    /// </summary>
    [FieldOffset(4)]
    public readonly FocusEventRecord FocusEvent;
}
```

**Size**: 20 bytes

---

## ConsoleScreenBufferInfo

```csharp
/// <summary>
/// Contains information about a console screen buffer.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows CONSOLE_SCREEN_BUFFER_INFO structure.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct ConsoleScreenBufferInfo
{
    /// <summary>
    /// Size of the screen buffer in character cells.
    /// </summary>
    public readonly Coord Size;

    /// <summary>
    /// Current cursor position in the buffer.
    /// </summary>
    public readonly Coord CursorPosition;

    /// <summary>
    /// Current text attributes (foreground/background colors).
    /// </summary>
    public readonly ushort Attributes;

    /// <summary>
    /// Visible portion of the screen buffer.
    /// </summary>
    public readonly SmallRect Window;

    /// <summary>
    /// Maximum window size based on buffer and font.
    /// </summary>
    public readonly Coord MaximumWindowSize;
}
```

**Size**: 22 bytes

---

## CharInfo

```csharp
/// <summary>
/// Specifies a character and its attributes for screen buffer output.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows CHAR_INFO structure. Used with WriteConsoleOutput.
/// </para>
/// <para>
/// Thread safety: Immutable value type; inherently thread-safe.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public readonly struct CharInfo : IEquatable<CharInfo>
{
    /// <summary>
    /// Unicode character to display.
    /// </summary>
    public readonly char UnicodeChar;

    /// <summary>
    /// Text and background color attributes.
    /// </summary>
    public readonly ushort Attributes;

    /// <summary>
    /// Initializes a new <see cref="CharInfo"/> with the specified character and attributes.
    /// </summary>
    public CharInfo(char unicodeChar, ushort attributes);

    // IEquatable<CharInfo> implementation
    public bool Equals(CharInfo other);
    public override bool Equals(object? obj);
    public override int GetHashCode();
    public static bool operator ==(CharInfo left, CharInfo right);
    public static bool operator !=(CharInfo left, CharInfo right);
}
```

**Size**: 4 bytes

---

## SecurityAttributes

```csharp
/// <summary>
/// Security attributes for handle creation operations.
/// </summary>
/// <remarks>
/// <para>
/// Maps to the Windows SECURITY_ATTRIBUTES structure.
/// </para>
/// <para>
/// Thread safety: Value type with no mutable state when used correctly.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Sequential)]
public struct SecurityAttributes
{
    /// <summary>
    /// Size of this structure in bytes.
    /// </summary>
    public uint Length;

    /// <summary>
    /// Pointer to a SECURITY_DESCRIPTOR structure.
    /// </summary>
    public nint SecurityDescriptor;

    /// <summary>
    /// If true, the handle can be inherited by child processes.
    /// </summary>
    public int InheritHandle;

    /// <summary>
    /// Creates a default instance with Length set to the struct size.
    /// </summary>
    public static SecurityAttributes Create();
}
```

**Size**: 12 bytes (x86) / 24 bytes (x64)
