# Full Coverage Checklist: Shortcut Utilities

**Purpose**: Comprehensive requirements quality validation across all dimensions — API fidelity, concurrency/dispatch, style merging, output redirection, edge cases, and testing strategy.
**Created**: 2026-02-01
**Feature**: [spec.md](../spec.md) | [plan.md](../plan.md) | [contracts](../contracts/shortcut-utils-api.md)
**Depth**: Standard (~28 items)
**Audience**: Reviewer (PR/pre-implementation validation)

## Requirement Completeness

- [x] CHK001 - Are all 5 Python source functions (`print_formatted_text`, `print_container`, `_create_merged_style`, `clear`, `set_title`/`clear_title`) accounted for in functional requirements? [Completeness, Spec §FR-001–FR-013] — **Yes.** FR-001 covers `print_formatted_text` (both overloads), FR-007 covers `print_container`, FR-005 now explicitly documents the `CreateMergedStyle` private helper and its merge order, FR-008/FR-009 cover `clear`/`set_title`/`clear_title`. FR-013 added for zero-value behavior.
- [x] CHK002 - Are requirements documented for the private `CreateMergedStyle` helper, including its merge order (default UI → Pygments → user)? [Completeness, Gap — private helper absent from FR list, only in plan] — **Fixed.** FR-005 now reads: "merge styles in a defined precedence order: (1) default UI style (lowest), (2) default Pygments style (conditional on `includeDefaultPygmentsStyle`), (3) user-provided style (highest precedence). This merge is performed by a private `CreateMergedStyle` helper using `StyleMerger.MergeStyles`."
- [x] CHK003 - Are requirements for the `styleTransformation` parameter specified beyond "configurable"? Does the spec define what transformations are supported or how they compose? [Completeness, Spec §FR-004] — **Fixed.** FR-004 now reads: "The `styleTransformation` is an `IStyleTransformation` passed through to the renderer for attribute modification before rendering."
- [x] CHK004 - Is the default `colorDepth` fallback behavior documented as a requirement (i.e., `output.GetDefaultColorDepth()` when not specified)? [Completeness, Gap — only in quickstart, not in spec FRs] — **Fixed.** FR-004 now reads: "When `colorDepth` is not specified, it defaults to `output.GetDefaultColorDepth()`."
- [x] CHK005 - Are requirements for zero-value `Print` invocation (`Print(Array.Empty<object>())`) formalized as a functional requirement, not just an edge case note? [Completeness, Spec Edge Cases §1] — **Fixed.** Added FR-013: "When the multi-value `Print` overload is called with zero values (empty array), it MUST still render the `end` string (default: newline) to the output."

## Requirement Clarity

- [x] CHK006 - Is "coordinates printing through the event loop" in FR-006 precisely defined? The spec says "event loop" but the plan uses `RunInTerminal.RunAsync` — is the dispatch mechanism clearly specified? [Clarity, Spec §FR-006] — **Fixed.** FR-006 now reads: "detect a running Application via `AppContext.GetAppOrNull()` and, when one is active, dispatch the render action through `RunInTerminal.RunAsync` to coordinate with the application's display lifecycle (suspend UI → print → resume). When no Application is running, the render action executes directly."
- [x] CHK007 - Is "renders any layout container non-interactively" in FR-007 clarified with the exact termination mechanism (`DummyInput` → `EndOfStreamException` catch)? [Clarity, Spec §FR-007] — **Fixed.** FR-007 now reads: "creating a temporary `Application<object?>` with `DummyInput`, running it via `Run(inThread: true)`, and catching the expected `EndOfStreamException` to signal normal termination."
- [x] CHK008 - Is "plain IList values" in FR-010 precise about which types qualify — non-generic `System.Collections.IList` but not `FormattedText` (which is `IReadOnlyList<StyleAndTextTuple>`)? [Clarity, Spec §FR-010] — **Fixed.** FR-010 now reads: "values implementing `System.Collections.IList` but NOT `FormattedText`" and the edge case bullet adds: "the non-generic `System.Collections.IList`, but NOT `FormattedText` which implements `IReadOnlyList<StyleAndTextTuple>`."
- [x] CHK009 - Does "default output" in acceptance scenario US1-AS1 unambiguously mean `AppContext.GetAppSession().Output` rather than `Console.Out`? [Clarity, Spec §US1-AS1] — **Fixed.** US1-AS1 now reads: "written to the current session's output (`AppContext.GetAppSession().Output`)."

## Requirement Consistency

- [x] CHK010 - Is the public API naming consistent across artifacts? The spec uses `PrintFormattedText` (FR-001, US1) but contracts/plan use `FormattedTextOutput.Print`. Are these reconciled? [Consistency, Spec §FR-001 vs Contracts §FormattedTextOutput] — **Fixed.** All spec references updated from `PrintFormattedText` to `FormattedTextOutput.Print` throughout (user stories, FRs, SCs, edge cases).
- [x] CHK011 - Are the assumption method names consistent with the actual codebase? Spec says `AppSession.Current.Output` and `Application.GetCurrentOrNull()` but research confirms `AppContext.GetAppSession().Output` and `AppContext.GetAppOrNull()`. [Consistency, Spec §Assumptions vs Research R-002] — **Fixed.** All 6 assumptions now use correct codebase names: `RendererUtils.PrintFormattedText`, `AppContext.GetAppSession().Output`, `AppContext.GetAppOrNull()`, `StyleMerger.MergeStyles`, `DummyInput`, `IOutput` methods. Exact signatures included.
- [x] CHK012 - Does the "6 public API methods" count in SC-001 match exactly — `Print` (single), `Print` (multi), `PrintContainer`, `Clear`, `SetTitle`, `ClearTitle` = 6? [Consistency, Spec §SC-001 vs Contracts] — **Fixed.** SC-001 now reads: "`FormattedTextOutput.Print` x2 overloads, `FormattedTextOutput.PrintContainer`, `TerminalUtils.Clear`, `TerminalUtils.SetTitle`, `TerminalUtils.ClearTitle`" — 6 methods with correct class-qualified names.

## Acceptance Criteria Quality

- [x] CHK013 - Is SC-004 ("dispatches through the event loop without corrupting the active UI") measurable in a real test scenario without mocking the Application event loop? [Measurability, Spec §SC-004] — **Fixed.** SC-004 now reads: "produces observable output in the captured stream without corrupting the Application's subsequent rendering. Verified by creating a real Application with DummyInput on a background thread, calling Print, and inspecting the output."
- [x] CHK014 - Is SC-008 ("80% code coverage") defined with the measurement approach given the no-mocks constraint (Constitution VIII)? What counts — line coverage, branch coverage? [Measurability, Spec §SC-008] — **Fixed.** SC-008 now reads: "80% line coverage of the `FormattedTextOutput` and `TerminalUtils` classes, measured by `dotnet test --collect:\"XPlat Code Coverage\"`."
- [x] CHK015 - Are US2 acceptance scenarios concrete enough to verify? "Dispatched through RunInTerminal" is an implementation detail — what observable output behavior should the test assert? [Measurability, Spec §US2-AS1] — **Fixed.** US2-AS1 now ends with: "The printed text is observable in the output stream." US2 Independent Test describes: creating a real Application with DummyInput, starting on a background thread, calling Print, verifying text appears in captured output.

## Scenario Coverage

- [x] CHK016 - Are requirements defined for `Print` overload resolution — when a single `object` argument could match either `AnyFormattedText` or `object[]`, which overload is selected? [Coverage, Gap] — **Fixed.** Added edge case: "The `Print(AnyFormattedText)` overload is preferred for types with implicit conversion to `AnyFormattedText` (string, Html, Ansi, FormattedText). The `Print(object[])` overload is used for explicit arrays of multiple values."
- [x] CHK017 - Are requirements specified for `PrintContainer` when the container renders to zero height or has no visible content? [Coverage, Gap] — **Fixed.** Added US3-AS4: "Given an empty container with no visible content, When `FormattedTextOutput.PrintContainer(container)` is called, Then the method completes normally (renders whatever the container produces, even if empty)."
- [x] CHK018 - Are requirements defined for `Print` when an explicit `output` parameter is provided — does it bypass `AppContext.GetAppSession().Output` entirely? [Coverage, Spec §FR-003] — **Fixed.** FR-003 now reads: "When `output` is provided, it is used directly, bypassing the session's default output." Added US1-AS10 for explicit output parameter.
- [x] CHK019 - Are requirements for `includeDefaultPygmentsStyle = false` covered by an acceptance scenario, not just an edge case bullet? [Coverage, Spec §FR-012 vs Edge Case §6] — **Fixed.** Added US1-AS9: "Given `includeDefaultPygmentsStyle: false`, When `FormattedTextOutput.Print` is called, Then only the default UI style (and optionally user style) is used — the default Pygments/syntax highlighting style is excluded."

## Edge Case Coverage

- [x] CHK020 - Is the behavior of `Print` with both empty `sep` ("") and empty `end` ("") specified? [Edge Case, Spec §FR-002] — **Fixed.** FR-002 now specifies: "When `sep` is empty, values are concatenated without spacing. When `end` is empty, no trailing character is appended." Added edge case bullet: "When both `sep` and `end` are empty strings? Values are concatenated directly with no spacing and no trailing newline."
- [x] CHK021 - Are requirements defined for calling `PrintContainer` while an Application is already running? Does it conflict with the running app's layout? [Edge Case, Gap] — **Fixed.** Added edge case: "The `PrintContainer` method creates its own temporary `Application`, independent of the running one. The running Application is not affected."
- [x] CHK022 - Is behavior specified when `file` is `TextWriter.Null`? OutputFactory maps this to `DummyOutput` — is that documented as expected? [Edge Case, Gap] — **Fixed.** Added edge case: "`OutputFactory.Create` maps `TextWriter.Null` to `DummyOutput`, which silently discards all output. This is expected behavior."

## Dependencies & Assumptions

- [x] CHK023 - Are all 6 spec assumptions validated against the actual codebase signatures (research R-001 through R-009 confirm availability, but spec assumption names differ)? [Assumption, Spec §Assumptions] — **Fixed.** All 6 assumptions updated to match actual codebase: `RendererUtils.PrintFormattedText` (was `Renderer.PrintFormattedText`), `AppContext.GetAppSession().Output` (was `AppSession.Current.Output`), `AppContext.GetAppOrNull()` (was `Application.GetCurrentOrNull()`), exact signature included for RendererUtils, `AsyncLocal<AppSession>` backing noted, `GetDefaultColorDepth()` added to IOutput methods.
- [x] CHK024 - Is the `EndOfStreamException` ↔ Python `EOFError` mapping documented as a deliberate design choice with rationale? [Assumption, Research R-007] — **Fixed.** Assumption 5 now reads: "`EndOfStreamException` — the .NET standard exception for end-of-stream conditions, equivalent to Python's `EOFError`." Edge case bullet 3 also documents the mapping.
- [x] CHK025 - Are layer dependency boundaries explicitly documented — `Stroke.Shortcuts` (layer 8) depends on layers 1-7 but nothing above? [Dependency, Plan §Constitution III] — **Fixed.** Added to spec header: "**Layer**: Stroke.Shortcuts (layer 8) — depends on Application (7), Layout (5), Rendering (2), Styles, Output, Input, FormattedText. Nothing above layer 8 may depend on this feature."

## Testing Strategy

- [x] CHK026 - Are testing requirements clear about verifying running-app dispatch without mocks? What real infrastructure is used to simulate a running Application? [Coverage, Spec §SC-004 vs Constitution VIII] — **Fixed.** US2 Independent Test now reads: "creating a real `Application` with `DummyInput`, starting it on a background thread, calling `FormattedTextOutput.Print`, and verifying the printed text appears in the captured output stream. No mocks are used." SC-004 specifies the same approach.
- [x] CHK027 - Are escape sequence capture requirements for `Clear` and `SetTitle` specified with a concrete approach (e.g., `Vt100Output.FromPty(writer)` + raw inspection)? [Clarity, Spec §US4 vs Quickstart §Testing Strategy] — **Fixed.** US4 Independent Test now reads: "capturing raw output via `Vt100Output.FromPty(stringWriter)` and verifying the correct VT100 escape sequences are emitted (e.g., `\x1b[2J` for erase screen, `\x1b[0;0H` for cursor home, `\x1b]2;...\x07` for title)." SC-006/SC-007 reference "inspecting raw output from `Vt100Output`."
- [x] CHK028 - Is the test strategy for style merging (verifying correct precedence: default UI < Pygments < user) documented with measurable assertions? [Coverage, Spec §FR-005] — **Fixed.** Added SC-009: "Style merging precedence is verified: user style overrides Pygments style which overrides default UI style. Tested using real `Style.FromDict()` instances and verifying the rendered output attributes reflect the correct precedence."

## Notes

- ✅ All 28 items completed on 2026-02-01
- Spec strengthened with: 4 new edge cases, 1 new FR (FR-013), 1 new SC (SC-009), 2 new acceptance scenarios (US1-AS9, US1-AS10, US3-AS4), layer boundary documentation, corrected method names throughout, precise type boundaries, concrete testing strategies
- Key naming inconsistencies resolved: `PrintFormattedText` → `FormattedTextOutput.Print`, `AppSession.Current.Output` → `AppContext.GetAppSession().Output`, `Application.GetCurrentOrNull()` → `AppContext.GetAppOrNull()`, `Renderer.PrintFormattedText` → `RendererUtils.PrintFormattedText`
