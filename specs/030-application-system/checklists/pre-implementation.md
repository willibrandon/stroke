# Pre-Implementation Quality Checklist: Application System

**Purpose**: Validate specification, contract, and planning artifact quality before implementation begins
**Created**: 2026-01-29
**Feature**: [spec.md](../spec.md) | [plan.md](../plan.md) | [contracts/](../contracts/)
**Focus**: Full requirements quality, Thread safety & concurrency, Cross-platform behavior, API contract quality
**Depth**: Standard
**Audience**: Author (pre-implementation gate)

## Requirement Completeness

- [x] CHK001 - Are all 36 functional requirements (FR-001 through FR-036) traceable to at least one acceptance scenario in the user stories? [Completeness, Spec §FR] — Added FR traceability note to FRs, added US-11 (Configuration Properties and Computed State) and US-12 (Typeahead Buffer) covering previously untraceable FRs (FR-019, FR-024, FR-025, FR-027, FR-032, FR-033, FR-034, FR-035, FR-036, FR-037, FR-038). Also added FR-037 (typeahead) and FR-038 (ExitStyle).
- [x] CHK002 - Is the behavior of `InputHook` fully specified, including when it is called, what it should do, and how it interacts with the event loop? [Completeness, Spec §FR-031] — Expanded FR-031 with full InputHook specification: when called (idle, waiting for input), what it does (monitors FD, calls InputIsReady), sync-only (Run, not RunAsync), null default behavior.
- [x] CHK003 - Are the default values for all 27 constructor parameters documented in both the spec and the contract? [Completeness, Contract application.md] — Contract application.md constructor signature includes all defaults inline. Spec FRs reference behavior but don't duplicate parameter defaults (appropriate separation).
- [x] CHK004 - Is the `PreRunCallables` lifecycle fully specified — when items are added, when they execute, whether they survive across multiple `Run()` calls? [Completeness, Spec §FR-030] — Expanded FR-030 and contract XML doc: execute after Reset() before first render, list cleared after execution, items accumulate between runs.
- [x] CHK005 - Are requirements defined for what happens when `Application<TResult>` is reused across multiple sequential `Run()` calls (REPL pattern)? [Completeness, Spec §US-9] — US-9 covers Reset() which enables REPL reuse. US-12 covers typeahead replay across runs. US-11 scenario 8 covers PreRunCallables clearing.
- [x] CHK006 - Is the `TypeaheadBuffer` integration specified — how unprocessed keys from `KeyProcessor.EmptyQueue()` are stored and replayed? [Gap, Contract key-processor.md] — Added FR-037 to spec, US-12 with acceptance scenarios, expanded EmptyQueue() XML doc in key-processor contract.
- [x] CHK007 - Are requirements defined for the `Renderer`'s CPR (Cursor Position Report) flow — request, timeout, callback, and retry behavior? [Completeness, Contract renderer.md] — Expanded RequestAbsoluteCursorPosition() and WaitForCprResponsesAsync() XML docs with full CPR lifecycle.
- [x] CHK008 - Is the `ExitStyle` property's purpose and rendering behavior specified beyond its declaration? [Gap, Contract application.md] — Added FR-038 to spec, expanded ExitStyle XML doc explaining when set, when reset, how used during final render.
- [x] CHK009 - Are the `SearchLinks` lifecycle requirements defined — when links are added/removed, and how they affect `IsSearching`? [Gap, Contract layout.md] — Expanded SearchLinks XML doc: added when search starts, removed when ends, IsSearching checks current focus.
- [x] CHK010 - Is the `VisibleWindows` update mechanism specified — who updates it, when, and how it relates to the render cycle? [Gap, Contract layout.md] — Expanded VisibleWindows XML doc: updated by Renderer via UpdateParentsRelations(), contains only rendered windows, empty before first render.

## Requirement Clarity

- [x] CHK011 - Is "configurable throttling" (FR-006) quantified — are the units (seconds vs milliseconds), default values, and boundary behavior (zero, negative, null) all explicit? [Clarity, Spec §FR-006] — Expanded FR-006 with units (seconds), defaults, zero/negative/null behavior, and interaction between MinRedrawInterval and MaxRenderPostponeTime. Concurrent coalescing documented.
- [x] CHK012 - Is "automatically cancelled when the application exits" (FR-008) specific about cancellation ordering — are background tasks cancelled before or after the final render? [Clarity, Spec §FR-008] — Expanded FR-008 with full 8-step shutdown ordering from Python source: final render first, background task cancellation last (in finally block).
- [x] CHK013 - Is the `maxRenderPostponeTime` default of `0.01` clearly specified as seconds, and is the interaction with `minRedrawInterval` when both are set defined? [Clarity, Contract application.md] — Units (seconds) specified in FR-006 and contract parameter doc. Interaction defined in FR-006: MinRedrawInterval defers scheduling, MaxRenderPostponeTime limits async postponement.
- [x] CHK014 - Is the term "event loop" used consistently throughout the spec, and is its .NET equivalent (`SynchronizationContext`, `TaskScheduler`, or raw `Task` scheduling) defined once and referenced? [Clarity, Spec §Assumptions] — Added definition to Assumptions: "The term 'event loop' in this spec refers to the .NET async/await execution context, not a custom loop implementation."
- [x] CHK015 - Is the `ColorDepthOption.Resolve(IOutput)` resolution order explicit — fixed value first, then callable, then output default? [Clarity, Contract application.md] — Added XML doc to Resolve() with explicit 3-step priority: fixed value → callable → output default.
- [x] CHK016 - Is the `CombinedRegistry` merge priority described identically in the spec (FR-004) and the contract (combined-registry.md), including the "reversed" detail? [Clarity, Spec §FR-004 vs Contract] — Expanded FR-004 with full 6-level priority list matching combined-registry.md, including the "reversed" detail and cross-reference.
- [x] CHK017 - Is "dummy buffer" (returned by `CurrentBuffer` when no buffer focused) specified — is it a new instance each time, a singleton, or null? [Ambiguity, Contract application.md §CurrentBuffer] — Expanded CurrentBuffer XML doc: new dummy Buffer("dummy-buffer") on each access (not singleton, not null). Matches Python: `Buffer(name="dummy-buffer")`.
- [x] CHK018 - Is "dummy SearchState" (returned by `CurrentSearchState`) similarly clarified? [Ambiguity, Contract application.md §CurrentSearchState] — Expanded CurrentSearchState XML doc: new default SearchState on each access (not singleton, not null). Matches Python: `SearchState()`.
- [x] CHK019 - Are the `FilterOrBool` parameter semantics explicit — does `default` mean `false`, `Never`, or "unset"? Is this consistent across `mouseSupport`, `pasteMode`, `reverseViSearchDirection`? [Clarity, Contract application.md] — Added explicit `default` = `false` documentation to mouseSupport, pasteMode, reverseViSearchDirection, and enablePageNavigationBindings param docs. Consistent across all FilterOrBool params.

## Requirement Consistency

- [x] CHK020 - Does the `DummyApplication` contract (app-context.md) match the spec's edge case for "no application running returns DummyApplication" (US-10, Edge Case 6)? [Consistency, Spec §US-10 vs Contract] — Verified: US-10 scenario 1 ("GetApp() returns DummyApplication") matches DummyApplication contract in app-context.md. Edge case 6 ("multiple apps in same session") matches SetApp() semantics. Consistent.
- [x] CHK021 - Is `Application<TResult>` vs `Application<object?>` usage consistent — does CombinedRegistry accept the former or the latter, and how does the generic covariance work? [Consistency, Contract application.md vs combined-registry.md] — Added generic covariance note to Application class remarks: internal components use Application<object?>, the Application provides an internal cast mechanism. Not visible in public API.
- [x] CHK022 - Does the `Renderer.Render()` signature accepting `Application<object?>` match the generic `Application<TResult>` — is explicit casting required and documented? [Consistency, Contract renderer.md] — Covered by CHK021's generic covariance note. Renderer, CombinedRegistry, and KeyPressEvent all use Application<object?> and receive the cast internally.
- [x] CHK023 - Are the `Reset()` responsibilities consistently divided between Application, Layout, KeyProcessor, Renderer, ViState, and EmacsState across all contracts? [Consistency, Spec §US-9 vs Contracts] — Expanded Application.Reset() XML doc with explicit 9-step execution order matching Python source. Each component's Reset() is documented in its own contract.
- [x] CHK024 - Is the `Layout.CurrentWindow` setter behavior consistent with the `Focus()` method — can both set focus, and if so, do they have the same validation? [Consistency, Contract layout.md] — Expanded CurrentWindow XML doc: setter and Focus() are equivalent (both push to focus stack). Setter does NOT validate focusability (matches Python behavior).
- [x] CHK025 - Are the `beforeRender`/`afterRender` callback parameters (Application constructor) consistent with the `BeforeRender`/`AfterRender` Event properties — do both fire, and in what order? [Consistency, Contract application.md] — Expanded BeforeRender/AfterRender XML docs: constructor callbacks are registered as first handlers, additional handlers added via +=. Constructor callback fires first.

## Acceptance Criteria Quality

- [x] CHK026 - Is SC-001 ("under 100ms of overhead") measurable in a test — what exactly is measured (constructor time, time-to-first-render, total run-exit latency)? [Measurability, Spec §SC-001] — Added measurement method: total run-exit latency via Stopwatch, pipe input with ENTER key, immediate Exit().
- [x] CHK027 - Is SC-002 ("exactly one scheduled redraw per invalidation cycle") testable — how is an "invalidation cycle" boundary defined and observed in a test? [Measurability, Spec §SC-002] — Added cycle definition: starts when _invalidated→true, ends when _redraw sets it→false. Test verifies RenderCounter increment.
- [x] CHK028 - Is SC-004 ("within 1 second of application exit") a hard timeout or soft expectation — what happens if a background task does not respond to cancellation? [Measurability, Spec §SC-004] — Specified as hard timeout. If task ignores CancellationToken, app proceeds after timeout (task becomes fire-and-forget).
- [x] CHK029 - Is SC-008 ("80% test coverage") specified with a coverage tool and measurement scope (line, branch, or method coverage)? [Measurability, Spec §SC-008] — Specified: line coverage via dotnet-coverage or coverlet. Scope: all .cs files in Application, Layout.cs, Renderer*.cs, KeyProcessor.cs directories.
- [x] CHK030 - Is SC-009 ("no source file exceeds 1,000 LOC") defined with a counting method — are blank lines, comments, and XML docs counted? [Measurability, Spec §SC-009] — Specified: physical lines including blanks/comments/XML docs, counted by `wc -l`.

## Scenario Coverage

- [x] CHK031 - Are acceptance scenarios defined for `RunAsync()` being called when another application is already running in the same session? [Coverage, Spec §US-1] — Added US-1 scenario 7: RunAsync on already-running instance throws InvalidOperationException.
- [x] CHK032 - Are acceptance scenarios defined for `CreateBackgroundTask()` being called after the application has exited? [Coverage, Spec §US-6] — Added US-6 scenario 5: CreateBackgroundTask after exit is a silent no-op.
- [x] CHK033 - Are acceptance scenarios defined for `RunInTerminal` being called when no application is running? [Coverage, Spec §US-7] — Added US-7 scenario 6: RunInTerminal with no app executes directly on terminal.
- [x] CHK034 - Are acceptance scenarios defined for `Focus()` targeting a non-visible or filtered-out container? [Coverage, Contract layout.md] — Added edge case: Focus on non-visible window is allowed (no validation of visibility).
- [x] CHK035 - Are acceptance scenarios defined for `CombinedRegistry` behavior when the focused window changes mid-key-sequence in `KeyProcessor`? [Coverage, Contract combined-registry.md vs key-processor.md] — Added edge case: CombinedRegistry re-evaluates cache on next GetBindingsForKeys call after focus change.
- [x] CHK036 - Are acceptance scenarios defined for `AppSession.Dispose()` being called while an application is still running inside it? [Coverage, Contract app-context.md] — Added edge case: Dispose restores previous session, running app continues with its own I/O references.
- [x] CHK037 - Are scenarios defined for the `Renderer` when terminal size changes between `Render()` calls (resize race)? [Coverage, Contract renderer.md] — Added edge case: In-progress render completes at old size, resize handler triggers full redraw at new size.

## Edge Case Coverage

- [x] CHK038 - Is edge case "Exit() called before RunAsync()" (spec edge case 1) reflected in the contract with a specific exception type? [Edge Case, Spec §Edge Cases vs Contract] — Updated spec edge case with InvalidOperationException and message "Application is not running". Updated Exit() XML doc with both exception conditions.
- [x] CHK039 - Is edge case "Exit() called twice" (spec edge case 2) specified with the exact exception type and message? [Edge Case, Spec §Edge Cases] — Updated spec edge case with InvalidOperationException and message "Result has already been set". Documented in Exit() contract exception doc.
- [x] CHK040 - Is the edge case of `refreshInterval` set to a negative value addressed? The spec covers zero and null but not negative. [Gap, Spec §Edge Cases] — Added edge case: negative refreshInterval treated as null (disabled), no exception.
- [x] CHK041 - Is the edge case of `minRedrawInterval` set to zero vs null distinguished — does zero mean "no throttle" or "immediate"? [Edge Case, Spec §FR-006] — Added edge case: zero means "no throttle" identical to null. Also clarified in FR-006.
- [x] CHK042 - Is the edge case of calling `Invalidate()` from within a `BeforeRender` or `AfterRender` callback addressed (recursive invalidation)? [Gap] — Added edge case: safe, schedules new redraw after current cycle completes (deferred, not recursive).
- [x] CHK043 - Is the edge case of `Layout` containing only non-focusable windows addressed — what happens on construction and on `FocusNext()`/`FocusPrevious()`? [Edge Case, Contract layout.md] — Added edge case: no-window throws InvalidLayoutException; all-non-focusable windows allowed, focus stays on first window.
- [x] CHK044 - Is the edge case of `RunSystemCommandAsync()` being called when the application is not running specified? [Gap, Contract application.md] — Added edge case: executes command directly without suspension when not running.

## Thread Safety & Concurrency Requirements

- [x] CHK045 - Is the thread safety contract for `Application<TResult>` specific about which methods are safe to call from any thread vs. which require the async context? [Clarity, Contract application.md] — Added detailed thread safety contract to Application remarks: safe-from-any-thread (Invalidate, Exit, CreateBackgroundTask, immutable getters), async-context-only (RunAsync, Reset, _redraw, etc.), mutable setters (Lock).
- [x] CHK046 - Is the synchronization mechanism for `Invalidate()` specified at the requirement level — do the spec/contracts state that concurrent calls coalesce to a single redraw? [Completeness, Spec §FR-006] — Expanded Invalidate() XML doc with coalescing semantics, _invalidated flag behavior, and Interlocked/Lock synchronization. Also expanded FR-006.
- [x] CHK047 - Is the thread safety of `Layout.Focus()` / `FocusNext()` / `FocusPrevious()` specified — can focus changes occur from background tasks? [Clarity, Contract layout.md] — Added thread-safe documentation: synchronized via Lock, callable from background tasks, changes take effect on next render.
- [x] CHK048 - Is the thread safety boundary between `KeyProcessor` (not thread-safe) and `Application.Invalidate()` (thread-safe) clearly documented — how does input from a background thread reach the KeyProcessor? [Clarity, Contract key-processor.md] — Expanded KeyProcessor remarks with thread boundary documentation: input callback runs in async context via SynchronizationContext.Post, SIGINT via call_soon_threadsafe equivalent.
- [x] CHK049 - Are race conditions between `Exit()` and `Invalidate()` addressed — what happens when `Exit()` is called from one thread while a redraw is in progress on another? [Gap] — Added "Thread Safety Notes" section to spec: Exit uses TrySetResult (thread-safe), in-progress _redraw completes normally, next redraw no-ops when _isRunning==false.
- [x] CHK050 - Is the `CancellationToken` propagation for background tasks specified — is it per-task, per-application, or shared? [Completeness, Spec §FR-008] — Expanded CreateBackgroundTask() XML doc: per-application CancellationTokenSource, all tasks share the same token, cancelled simultaneously on exit.
- [x] CHK051 - Is the lock ordering documented for classes that may acquire multiple locks (e.g., Application Lock + Layout Lock during rendering)? [Gap] — Added lock ordering to spec Thread Safety Notes: Application Lock (outermost) > Layout Lock. Renderer/KeyProcessor are single-threaded. _backgroundTasks has independent Lock.
- [x] CHK052 - Are the thread safety requirements for `AppSession.App` property (internal setter) specified — can two threads race to set the active app? [Clarity, Contract app-context.md] — Added to spec Thread Safety Notes: AsyncLocal provides per-execution-context isolation, so threads cannot race. App setter still uses Lock for defense-in-depth.

## Cross-Platform Behavior Requirements

- [x] CHK053 - Is the Windows fallback for SIGWINCH (polling) fully specified — polling interval, detection mechanism, and behavior when interval is null? [Completeness, Spec §FR-013] — Expanded FR-013: polling via IOutput.GetSize() at TerminalSizePollingInterval, null disables, Windows always polls, Unix polls on non-main thread.
- [x] CHK054 - Is `SuspendToBackground()` behavior on Windows explicitly defined as "no-op" in both the spec and contract? [Completeness, Spec §FR-023 vs Contract] — Expanded FR-023 with explicit "no-op on Windows." Updated SuspendToBackground() contract XML doc to specify "No-op on Windows (SIGTSTP not available)."
- [x] CHK055 - Is the `PosixSignalRegistration` availability requirement specified — what .NET version is minimum, and what happens on older runtimes? [Clarity, Spec §Assumptions] — Added to Assumptions: minimum .NET 6 for PosixSignalRegistration, graceful degradation to polling-only on older runtimes.
- [x] CHK056 - Are terminal raw mode enter/exit requirements specified for both Unix (termios) and Windows (Console mode flags)? [Gap] — Added to FR-014: raw mode managed by IInput.RawMode() returning IDisposable. Unix uses termios, Windows uses Console mode flags. Enters at RunAsync start, exits in finally block.
- [x] CHK057 - Is the alternate screen buffer behavior (FR-014) specified for terminals that don't support it? [Edge Case, Spec §FR-014] — Added to FR-014: EnterAlternateScreen/LeaveAlternateScreen are no-ops on unsupported terminals (output implementation handles degradation).
- [x] CHK058 - Is `CreateAppSessionFromTty()` behavior specified when no TTY is available (e.g., running in a Docker container without a PTY)? [Edge Case, Contract app-context.md] — Expanded CreateAppSessionFromTty() XML doc: falls back to DummyInput/DummyOutput when no TTY available, no exception.
- [x] CHK059 - Is the `RunSystemCommandAsync()` shell resolution specified per platform — `/bin/sh -c` on Unix vs `cmd /c` on Windows? [Gap, Contract application.md] — Added platform-specific shell resolution to RunSystemCommandAsync() XML doc: Unix uses /bin/sh -c, Windows uses cmd /c.

## API Contract Quality

- [x] CHK060 - Do all 6 contract files define XML doc comments for every public member (type, property, method, parameter)? [Completeness, Contracts] — Verified: all 6 contracts have XML docs for all public types, properties, methods, and parameters. Enhanced during this checklist pass with additional detail.
- [x] CHK061 - Are exception types and conditions documented for all methods that can throw (Exit, Focus, Run, RunAsync)? [Completeness, Contracts] — Added InvalidOperationException and EndOfStreamException to RunAsync/Run. Exit already had InvalidOperationException. Focus already had InvalidOperationException. Layout constructor already had InvalidLayoutException.
- [x] CHK062 - Are `IDisposable`/`IAsyncDisposable` implementations documented with disposal semantics for `AppSession` and `InTerminal()`? [Completeness, Contract app-context.md] — Expanded AppSession.Dispose() (restores session, doesn't close I/O, idempotent) and InTerminal() return doc (resumes app on dispose, must be disposed).
- [x] CHK063 - Is the `Application<TResult>` class marked `sealed` or left inheritable — and is this decision documented with rationale? [Clarity, Contract application.md] — Added inheritance note: NOT sealed because DummyApplication inherits from it. User subclassing not recommended but not prevented. Matches Python design.
- [x] CHK064 - Is the `internal` visibility of `CombinedRegistry` and `AppSession.App` justified with rationale in the contracts? [Clarity, Contract combined-registry.md, app-context.md] — Added visibility rationale to CombinedRegistry (implementation detail, not public contract) and AppSession.App (prevents breaking context invariant, public access via GetApp/SetApp).
- [x] CHK065 - Are the 15 `AppFilters` properties specified with enough detail to implement — does each one reference which application/layout/buffer state it queries? [Completeness, Contract combined-registry.md] — Expanded all 15 AppFilters with specific "Queries:" annotations showing exact property/method accessed for each filter.
- [x] CHK066 - Is the `ScreenDiff.OutputScreenDiff` return type `(Point, string?)` documented with semantic meaning for each tuple element? [Clarity, Contract renderer.md] — Added semantic docs: CursorPos = cursor position after diff output, LastStyle = last emitted style string for avoiding redundant escape sequences.
- [x] CHK067 - Are the `Renderer.Render()` side effects documented — what state it mutates (LastRenderedScreen, RenderCounter, AttrsForStyle, RowsAboveLayout)? [Completeness, Contract renderer.md] — Added comprehensive side effects list to Render() XML doc: 7 state mutations + note that RenderCounter is incremented by Application, not Renderer.
- [x] CHK068 - Is the `KeyProcessor.ProcessKeys()` dispatch algorithm documented — prefix matching, exact matching, flush timeout, and what happens with no match? [Completeness, Contract key-processor.md] — Added 6-step dispatch algorithm: exact match, prefix match, eager bindings, no match flush, flush timeout (ttimeoutlen/timeoutlen), handler dispatch with events.

## Dependencies & Assumptions

- [x] CHK069 - Is the assumption that `DummyInput`/`DummyOutput` already exist validated against the current codebase? [Assumption, Spec §Assumptions] — Validated: DummyInput exists at src/Stroke/Input/DummyInput.cs (sealed, IInput). DummyOutput exists at src/Stroke/Output/DummyOutput.cs (sealed, IOutput). Both are thread-safe (stateless).
- [x] CHK070 - Are all 7 missing dependencies identified in research.md (Layout class, KeyProcessor, Renderer, DummyLayout, DefaultKeyBindings, PrintFormattedText, AppFilters) accounted for in the project structure? [Completeness, Plan §Project Structure] — Validated: all 7 are listed in the plan.md Project Structure section under their respective directories (Layout/, Rendering/, KeyBinding/, Application/).
- [x] CHK071 - Is the dependency on `Wcwidth` NuGet package justified for this feature — does Application directly use character width, or is it transitive? [Assumption, Plan §Technical Context] — Validated: Wcwidth is already in Stroke.csproj. Application doesn't use it directly — it's used by Screen/Char (Feature 028) and Renderer's diff algorithm. The dependency is transitive for this feature. No new package reference needed.
- [x] CHK072 - Are the `IContainer`, `Window`, `BufferControl`, `FormattedTextControl`, `SearchBufferControl`, `DummyControl` dependencies from Feature 029 verified as implemented and available? [Assumption, Plan §Technical Context] — Validated: all 6 types exist in src/Stroke/Layout/Containers/ and src/Stroke/Layout/Controls/. Feature 029 is fully implemented.
- [x] CHK073 - Is the assumption that `AsyncLocal<T>` flows across `Task.Run()` and thread pool work items validated — are there known .NET scenarios where it does not flow? [Assumption, Spec §Assumptions] — Validated and documented in Assumptions: AsyncLocal flows through Task.Run(), async/await, and ExecutionContext.Run. Does NOT flow into raw Thread constructors or ThreadPool.QueueUserWorkItem by default. The `inThread` mode must explicitly copy context. This is documented in the updated Assumptions section.
- [x] CHK074 - Is the `StyleMerger` (existing) capable of the 3-way merge described in FR-005, or does the spec assume capabilities that may not exist? [Assumption, Spec §FR-005] — Validated: StyleMerger.MergeStyles(IEnumerable<IStyle?>) accepts any number of styles. The 3-way merge (default UI + conditional Pygments + user) is a direct call to MergeStyles([style1, style2, style3]). MergedStyle class handles multi-style composition with SimpleCache. Fully capable.

## Notes

- Check items off as completed: `[x]`
- Add findings or resolution notes inline after each item
- Items referencing `[Gap]` indicate requirements that may need to be added to spec/contracts before implementation
- Items referencing `[Assumption]` should be validated against the actual codebase state
- This checklist covers all four requested domains: full requirements quality, thread safety, cross-platform behavior, and API contract quality
