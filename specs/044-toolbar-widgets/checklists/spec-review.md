# Spec Review Checklist: Toolbar Widgets

**Purpose**: Comprehensive requirements quality review — port fidelity, constitution compliance, integration risk, and spec completeness for all 7 toolbar widget classes
**Created**: 2026-02-01
**Feature**: [spec.md](../spec.md) | [contracts](../contracts/toolbar-widgets.md) | [Python source](toolbars.py)
**Audience**: Pre-implementation review & PR review gate
**Depth**: Standard + Python cross-reference

## Requirement Completeness

- [x] CHK001 - Does the spec define how `FormattedTextToolbar` forwards additional `FormattedTextControl` parameters? Python accepts `**kw` and passes them through (e.g., `focusable`, `key_bindings`, `show_cursor`), but the C# contract only accepts `(AnyFormattedText text, string style = "")`. [Gap, Python L61 vs Contracts §FormattedTextToolbar] — **Resolved**: FR-001 now documents the **kw deviation explicitly with rationale. Data model updated. Contracts updated with remarks.
- [x] CHK002 - Is `SystemToolbar._get_display_before_text()` behavior specified? Python (L108-113) builds a formatted text list passed to `run_system_command` as `display_before_text`, but neither spec FRs nor contracts mention this private method or its output format. [Gap, Python L108-113] — **Resolved**: FR-002 now specifies `GetDisplayBeforeText()` method and its output format. Data model updated with full detail including hard-coded "Shell command: " behavior.
- [x] CHK003 - Are all parameters for the `Application.RunSystemCommandAsync` call documented? Python passes `(self.system_buffer.text, display_before_text=self._get_display_before_text())` but the C# method has 4 parameters (`command`, `waitForEnter`, `displayBeforeText`, `waitText`). Which defaults should the spec prescribe? [Gap, Spec §US2-Scenario 3] — **Resolved**: US2-Scenario 3 now specifies the exact method call with `displayBeforeText` parameter. Assumptions section documents the full signature with defaults.
- [x] CHK004 - Is the lazy evaluation of `SystemToolbar.Prompt` in the `BeforeInput` processor specified? Python wraps the prompt as `lambda: self.prompt` (L95) to ensure dynamic evaluation, not direct value passing. [Clarity, Spec §FR-002] — **Resolved**: FR-002 now specifies "lazily-evaluated BeforeInput prompt (wrapped as `() => Prompt`)". US2-Scenario 8 notes "evaluated lazily via `() => Prompt`".
- [x] CHK005 - Is the space separator between completion items in `CompletionsToolbarControl` documented? Python appends `("", " ")` after each completion (L304), affecting width calculations and visual appearance. [Gap, Python L304] — **Resolved**: FR-013 now specifies 'Each completion item is followed by a single-space separator fragment `("", " ")`'. Data model algorithm step 5 documents this.
- [x] CHK006 - Is the `fragments[:content_width]` safety trim in `CompletionsToolbarControl` specified? Python L308 limits fragment list count as a safety measure after padding. [Gap, Python L308] — **Resolved**: FR-013 now specifies "fragments MUST be safety-trimmed to `contentWidth` entries (`fragments[:contentWidth]`)". Data model algorithm step 7 documents this.
- [x] CHK007 - Does the spec define how `CompletionsToolbarControl` handles a `None` completion index? Python uses `index or 0` (L286) to default `None` to 0 for the page-forward comparison. [Gap, Python L270, L286] — **Resolved**: FR-013 now specifies "When `CompleteIndex` is null, it MUST be treated as 0 for page-forward comparison (`index ?? 0`)". Edge cases section documents this. Data model algorithm step 3 documents this.
- [x] CHK008 - Is the `ArgToolbar` null-arg fallback documented? Python uses `get_app().key_processor.arg or ""` (L194) to convert `None` to empty string before the `"-"` check. [Gap, Python L194] — **Resolved**: FR-007 now specifies "converting null to empty string (`arg ?? ""`) before the `-` check". Data model updated.
- [x] CHK009 - Does the spec define what `CompletionsToolbarControl.CreateContent` returns when `CompleteState` is null? Python returns `UIContent(get_line=get_line, line_count=1)` with empty fragments (L325-328). The spec only addresses visibility via `ConditionalContainer`. [Gap, Python L265-328] — **Resolved**: FR-013 now specifies "When `CompleteState` is null or has no completions, the control MUST return a `UIContent` with 1 line and empty fragments". Data model algorithm step 2 documents the exact return.
- [x] CHK010 - Is the `ValidationToolbar` empty-fragments return case documented? Python returns `[]` when no validation error (L361), distinct from the `ConditionalContainer` hiding. [Gap, Python L361] — **Resolved**: FR-017 now specifies "When no validation error exists, the control MUST return empty fragments `[]`". US6-Scenario 1 updated. Data model updated.
- [x] CHK011 - Are `BufferNames.System` or its equivalent explicitly identified as a required dependency? The data model references it but the spec's Dependencies section doesn't list it. [Gap, Data Model §SystemToolbar vs Spec §Dependencies] — **Resolved**: Dependencies section now includes `BufferNames` under Stroke.KeyBinding. FR-002 references `BufferNames.System` explicitly.
- [x] CHK012 - Does the spec address whether `SystemToolbar` exposes its internal key bindings field? Python stores `self._bindings` (L89) as private. The C# contracts don't expose it, but the decision should be explicit. [Gap, Python L89] — **Resolved**: Contracts now include a comment: "Private: IKeyBindingsBase _bindings — three-group merged key bindings (not exposed as property)". Data model documents the private field.

## Port Fidelity (Python Cross-Reference)

- [x] CHK013 - Does `FormattedTextToolbar` specify `dontExtendHeight: true` as a constructor parameter? Python explicitly sets `dont_extend_height=True` (L67). The contracts inherit from Window but don't show this parameter. [Completeness, Python L67 vs Contracts §FormattedTextToolbar] — **Resolved**: FR-001 now specifies "Window MUST set `dontExtendHeight: true`". Contracts updated with remarks showing the base constructor call. Data model updated.
- [x] CHK014 - Does `FormattedTextToolbar` specify `height: Dimension(min: 1)`? Python explicitly sets `height=Dimension(min=1)` (L68). The quickstart mentions it but the contracts and FRs don't. [Completeness, Python L68 vs Spec §FR-001] — **Resolved**: FR-001 now specifies "and `height: Dimension(min: 1)`". Contracts updated with remarks. Key Entities updated.
- [x] CHK015 - Does the spec capture that `SystemToolbar` Emacs cancel bindings use `focused` filter per-binding AND `emacs_mode` on the ConditionalKeyBindings wrapper? Python layers filtering: individual bindings check `has_focus(system_buffer)`, then the group is wrapped with `ConditionalKeyBindings(emacs_bindings, emacs_mode)` (L181). [Clarity, Python L122-124, L181 vs Spec §FR-003] — **Resolved**: FR-003 now specifies "wrapped in `ConditionalKeyBindings` gated by `EmacsFilters.EmacsMode`" with "each with per-binding `AppFilters.HasFocus(SystemBuffer)` filter". Data model documents both levels.
- [x] CHK016 - Is the `SystemToolbar` Vi cancel handler's order of operations specified? Python sets `input_mode = NAVIGATION` BEFORE `buffer.reset()` and `focus_last()` (L148-150). The spec mentions all three actions but not their order. [Clarity, Python L148-150 vs Spec §US2-Scenario 4] — **Resolved**: US2-Scenario 4 now specifies "in order: (1) `ViState.InputMode` is set to `InputMode.Navigation`, (2) `SystemBuffer.Reset()` is called, (3) `Layout.FocusLast()` restores focus". Data model documents the order.
- [x] CHK017 - Is the `SystemToolbar` Vi Enter handler's order of operations specified? Python sets `input_mode = NAVIGATION` BEFORE `run_system_command` (L155-156). [Clarity, Python L155-156 vs Spec §US2-Scenario 5] — **Resolved**: US2-Scenario 5 now specifies "in order: (1) `ViState.InputMode` is set to `InputMode.Navigation`, (2) `RunSystemCommandAsync` is awaited, (3) `SystemBuffer.Reset(appendToHistory: true)`, (4) `Layout.FocusLast()`". Data model documents the order.
- [x] CHK018 - Does the spec capture the exact filter for the M-! global binding? Python uses `~focused & emacs_mode` (L168), not just `emacs_mode`. [Completeness, Python L168 vs Spec §FR-005] — **Resolved**: FR-005 now specifies "M-! ... with filter `~HasFocus(SystemBuffer) & EmacsMode` and `isGlobal: true`". US2-Scenario 6 documents the full filter. Data model documents it.
- [x] CHK019 - Does the spec capture the exact filter for the Vi ! global binding? Python uses `~focused & vi_mode & vi_navigation_mode` (L173), a three-part conjunction. [Completeness, Python L173 vs Spec §FR-005] — **Resolved**: FR-005 now specifies '`"!"` with filter `~HasFocus(SystemBuffer) & ViMode & ViNavigationMode` and `isGlobal: true`'. US2-Scenario 7 documents the full filter. Data model documents it.
- [x] CHK020 - Is the M-! key sequence specified as `Keys.Escape, "!"` (two separate keys)? Python uses `Keys.Escape, "!"` (L168), not a single Meta key. [Clarity, Python L168 vs Spec §US2-Scenario 6] — **Resolved**: US2-Scenario 6 now specifies "M-! (the two-key sequence `Keys.Escape` then `\"!\"`)". FR-005 specifies "M-! (the two-key sequence `Keys.Escape`, `\"!\"`)"". Data model documents it.
- [x] CHK021 - Is the Vi ! global binding's `InputMode.INSERT` switch documented? Python sets `input_mode = InputMode.INSERT` (L176) before focusing. Spec §US2-Scenario 7 mentions "Vi input mode switches to Insert" — confirm contracts match. [Completeness, Python L176 vs Spec §US2-Scenario 7] — **Resolved**: US2-Scenario 7 now specifies "`ViState.InputMode` is set to `InputMode.Insert`". FR-005 specifies "to set `InputMode.Insert` and focus the toolbar window". Data model documents it.
- [x] CHK022 - Does the `CompletionsToolbarControl` spec capture the exact arrow margin layout? Python builds: `" "` + `"<"/""` + `" "` + content + `" "` + `">"/""` + `" "` (L311-323). That's 3+3=6 chars. Is this structure unambiguous? [Clarity, Python L311-323 vs Spec §FR-014] — **Resolved**: FR-014 now specifies the exact structure: '`" "` + `"<"` or `" "` + `" "` + content + `" "` + `">"` or `" "` + `" "`'.
- [x] CHK023 - Does the `SearchToolbar` spec capture that the `is_searching` condition is used for BOTH the `ConditionalContainer` filter AND the `BeforeInput` prompt selection? Python reuses the same `is_searching` closure for both purposes (L256, L234). [Completeness, Python L234, L256 vs Spec §FR-009] — **Resolved**: FR-009 now specifies "MUST be used for both the `ConditionalContainer` filter and the `BeforeInput` prompt selection logic". Data model documents this.
- [x] CHK024 - Is the `SearchToolbar` Window not exposed as a property, matching Python? Python doesn't expose the intermediate Window. The C# contracts expose `Control` and `Container` but no `Window`. Confirm this is intentional and matches. [Consistency, Python L254-257 vs Contracts §SearchToolbar] — **Resolved**: Verified correct — contracts expose `SearchBuffer`, `Control`, `Container` but no `Window`, matching Python exactly.
- [x] CHK025 - Does `ValidationToolbar` specify that the Window has NO style, with styling only on the text fragments? Python: `Window(self.control, height=1)` (L366) has no `style` param, but fragments use `"class:validation-toolbar"` (L359). The style table lists `class:validation-toolbar` under ValidationToolbar — is the application point clear? [Clarity, Python L359, L366 vs Contracts §Style Classes] — **Resolved**: FR-017 now specifies "The `class:validation-toolbar` style is applied to the text fragments, not the Window". Contracts style table updated with clarifying note. Data model updated.
- [x] CHK026 - Does `ArgToolbar` specify `height=1` on the Window? Python explicitly sets `height=1` (L203). Contracts don't show Window construction details. [Completeness, Python L203] — **Resolved**: Contracts ArgToolbar Window property now includes "(height=1, FormattedTextControl with styled 'Repeat: {arg}')". Key Entities updated with "(height: 1)".
- [x] CHK027 - Does `CompletionsToolbar` specify `height=1` and `style="class:completion-toolbar"` on the Window? Python: `Window(_CompletionsToolbarControl(), height=1, style="class:completion-toolbar")` (L335). [Completeness, Python L335] — **Resolved**: FR-016 now specifies 'The inner Window uses `height: 1` and `style: "class:completion-toolbar"`'. Key Entities updated. Data model already had this.

## Requirement Clarity & Ambiguity

- [x] CHK028 - Is "container protocol" consistently defined? FRs use "implementing the container protocol" (FR-002, FR-007, FR-009, FR-016, FR-017, FR-020) but don't name it as `IMagicContainer`. Only the contracts and key entities make this explicit. [Ambiguity, Spec §FR-002] — **Resolved**: All affected FRs (FR-002, FR-007, FR-009, FR-016, FR-017, FR-020) now say "implementing `IMagicContainer`" explicitly.
- [x] CHK029 - Is the `SystemToolbar` Enter handler explicitly specified as `async`? Python's `_accept` is `async def` (L131, L153). The spec says "the system command is executed" but doesn't mention async/await semantics. [Ambiguity, Spec §US2-Scenario 3] — **Resolved**: FR-002 now specifies "The Enter handlers MUST be async". FR-003 specifies "execute the system command asynchronously". US2-Scenario 3 specifies "the async handler calls".
- [x] CHK030 - Is "the system command is executed via the application" sufficiently precise? Which method (`RunSystemCommandAsync`), which parameters, and which overload? [Clarity, Spec §US2-Scenario 3] — **Resolved**: US2-Scenario 3 now specifies the exact call: `Application.RunSystemCommandAsync(SystemBuffer.Text, displayBeforeText: GetDisplayBeforeText())`. Assumptions section documents the full method signature.
- [x] CHK031 - Does "buffer is reset with history" clearly specify `Buffer.Reset(appendToHistory: true)` vs just `Buffer.Reset()`? The distinction between cancel (no history) and execute (with history) should be unambiguous. [Clarity, Spec §US2-Scenario 3 vs §US2-Scenario 2] — **Resolved**: US2-Scenario 2 now says `SystemBuffer.Reset()` "(without history append)". US2-Scenario 3 says `SystemBuffer.Reset(appendToHistory: true)`. Clear distinction.
- [x] CHK032 - Is "focus returns to the previous element" precisely defined as `Layout.FocusLast()` (pop from focus stack)? The method name could be confused with "focus the last element in the container." [Clarity, Spec §US2-Scenarios 2-5] — **Resolved**: All US2 scenarios now specify `Layout.FocusLast()` explicitly with "restores focus to the previously-focused element".
- [x] CHK033 - Is the term "completions that exceed the available width" measurable? FR-014 defines content width as `width - 6`, but acceptance scenarios (§US5-Scenarios 3-4) use informal language. [Measurability, Spec §US5-Scenarios 3-4] — **Resolved**: US5-Scenarios 3-4 now specify "combined display text plus space separators exceed the content width (total width - 6)".
- [x] CHK034 - Is "appropriate styling" in ArgToolbar (§US3-Scenario 2) quantified with specific style class names? [Measurability, Spec §US3-Scenario 2] — **Resolved**: US3-Scenario 2 now specifies exact style fragments: `[("class:arg-toolbar", "Repeat: "), ("class:arg-toolbar.text", "5")]`.

## Requirement Consistency

- [x] CHK035 - Are the style classes in the contracts' Style Classes Reference table consistent with those used in each class's implementation detail? Cross-reference all 12 style classes against their usage in data-model.md and Python source. [Consistency, Contracts §Style Classes vs Data Model] — **Resolved**: Verified all 12 style classes are consistent. `class:system-toolbar` (BeforeInput + Window), `class:system-toolbar.text` (SimpleLexer), `class:arg-toolbar`/`.text` (fragments), `class:search-toolbar` (Window), `class:search-toolbar.prompt` (BeforeInput), `class:search-toolbar.text` (SimpleLexer), `class:completion-toolbar` (Window), `class:completion-toolbar.completion`/`.current`/`.arrow` (fragments), `class:validation-toolbar` (fragments only, NOT Window). All match Python source.
- [x] CHK036 - Does the `SystemToolbar` contract's `Window` property match the data model's description? Contract says "Gets the window containing the buffer control" while data model says "Wraps BufferControl, height=1". Both should specify `style="class:system-toolbar"`. [Consistency, Contracts §SystemToolbar vs Data Model §SystemToolbar] — **Resolved**: Contracts Window property now says '(height=1, style="class:system-toolbar")'. Data model already specified this.
- [x] CHK037 - Is the `CompletionsToolbarControl` access level consistently specified? Contracts say `internal class`, data model says "internal", quickstart says "internal control". Confirm FR-013 also says "internal" (it says "internal UIControl"). [Consistency, Spec §FR-013 vs Contracts] — **Resolved**: Verified consistent — FR-013 says "internal `IUIControl`", contracts say "internal class", data model says "internal", quickstart says "internal control". All aligned.
- [x] CHK038 - Does the `SearchToolbar` `textIfNotSearching` default match between spec, contracts, and Python? Spec §US4 doesn't mention a default. Contracts say `default to ""`. Python default is `""` (L221). [Consistency, Spec §US4 vs Contracts §SearchToolbar vs Python L221] — **Resolved**: FR-009 now specifies 'Default `textIfNotSearching` is empty string `""`'. Contracts already specified this. Consistent with Python.

## Acceptance Criteria Quality

- [x] CHK039 - Can SC-001 ("constructable with documented parameters") be objectively measured without an explicit parameter list in the success criteria? [Measurability, Spec §SC-001] — **Resolved**: SC-001 now specifies "plus the internal `CompletionsToolbarControl`", references "(per contracts)", and includes "produce the expected inner container hierarchy".
- [x] CHK040 - Can SC-003 ("key bindings correctly cancel, execute, and focus") be verified through "key binding inspection and handler registration"? Are the inspection methods defined? [Measurability, Spec §SC-003] — **Resolved**: SC-003 now specifies "verifiable by inspecting `KeyBindings.Bindings` collections for expected key/filter/handler registrations across the three binding groups (emacs, vi, global)".
- [x] CHK041 - Does SC-004 specify what "correctly paginates" means for edge cases like width=7 (content_width=1) or width=6 (content_width=0)? [Measurability, Spec §SC-004] — **Resolved**: SC-004 now specifies "at any width >= 7 (`contentWidth >= 1`), produces empty/minimal content gracefully at width <= 6 (`contentWidth <= 0`)".
- [x] CHK042 - Does SC-007 ("80% coverage") define whether coverage is measured per-file, per-class, or across the entire toolbar namespace? [Clarity, Spec §SC-007] — **Resolved**: SC-007 now specifies "across all files in the `Stroke.Widgets.Toolbars` namespace, measured by line coverage" and includes the Constitution VIII requirement for real instances.

## Scenario Coverage

- [x] CHK043 - Is there an acceptance scenario for `SystemToolbar` with `enableGlobalBindings=false`? Edge case mentions it, but no formal Given/When/Then scenario exists. [Coverage, Spec §Edge Cases vs §US2] — **Resolved**: US2-Scenario 9 added: "Given a SystemToolbar with `enableGlobalBindings` set to false..."
- [x] CHK044 - Is there an acceptance scenario for `CompletionsToolbarControl` with width < 7 (content_width <= 0)? Edge case mentions it, but no formal scenario. [Coverage, Spec §Edge Cases vs §US5] — **Resolved**: US5-Scenario 7 added: "Given a CompletionsToolbar rendering at width W <= 6..."
- [x] CHK045 - Is there an acceptance scenario for completions containing wide (CJK) characters? Edge case mentions it, but no formal scenario with expected behavior. [Coverage, Spec §Edge Cases vs §US5] — **Resolved**: US5-Scenario 8 added: "Given a CompletionsToolbar with completions containing wide (CJK) characters..."
- [x] CHK046 - Is there an acceptance scenario for `ValidationToolbar` with an empty error message? Edge case mentions it, but no formal scenario. [Coverage, Spec §Edge Cases vs §US6] — **Resolved**: US6-Scenario 4 added: "Given a ValidationToolbar and a validation error with an empty message string..."
- [x] CHK047 - Is there an acceptance scenario for `SearchToolbar` with `textIfNotSearching` being non-empty? The parameter exists but no scenario tests its effect. [Coverage, Spec §US4] — **Resolved**: US4-Scenario 9 added: "Given a SearchToolbar with `textIfNotSearching` set to 'Type to search...'..."
- [x] CHK048 - Is there an acceptance scenario for `CompletionsToolbarControl` when `CompleteState` exists but has 0 completions? [Coverage, Gap] — **Resolved**: US5-Scenario 9 added: "Given a CompletionsToolbar where `CompleteState` exists but contains 0 completions..."
- [x] CHK049 - Is there an acceptance scenario for `CompletionsToolbarControl` when all completions fit exactly (no overflow, no room to spare)? [Coverage, Gap] — **Resolved**: US5-Scenario 10 added: "Given a CompletionsToolbar where all completions exactly fit within the content width..."
- [x] CHK050 - Are requirements defined for `ArgToolbar` when the arg value is a multi-digit number (e.g., "42")? Only single-digit "5" and edge case "-" are tested. [Coverage, Spec §US3] — **Resolved**: US3-Scenario 4 added: "Given an ArgToolbar and the key processor has arg '42'..."

## Edge Case & Boundary Coverage

- [x] CHK051 - Does the spec define behavior when `SearchToolbar.Control.SearcherSearchState` is null? Python accesses `self.control.searcher_search_state.direction` (L237) which could fail if the state is unset. [Edge Case, Python L237] — **Resolved**: New edge case added explaining that the `is_searching` condition gates prompt selection — the direction branch is only reached when `is_searching()` is true, avoiding null access. Data model documents the BeforeInput logic order.
- [x] CHK052 - Does the spec define behavior for `CompletionsToolbarControl` when exactly one completion exists? Single-item pagination is a boundary case. [Edge Case, Gap] — **Resolved**: New edge case added: "The CompletionsToolbarControl displays it without pagination arrows (neither `cut_left` nor `cut_right` is set)."
- [x] CHK053 - Does the spec define `CompletionsToolbar` behavior when completions list changes between renders (items added/removed)? [Edge Case, Gap] — **Resolved**: New edge case added: "The control reads `CompleteState` fresh on each `CreateContent` call, reflecting the current state."
- [x] CHK054 - Does the spec address what happens when `SystemToolbar`'s system buffer already has text at construction time? [Edge Case, Gap] — **Resolved**: New edge case added: "The Buffer is created fresh with `name: BufferNames.System`, so it starts empty."

## Constitution Compliance

- [x] CHK055 - Does the spec address Constitution Principle II (Immutability by Default) for the `CompletionsToolbarControl`? It reads mutable `CompleteState` during rendering. Are the mutability boundaries documented? [Constitution II, Spec §Assumptions] — **Resolved**: New "Constitution Compliance" section added. Principle II entry: "Toolbar classes hold readonly references to mutable objects. `CompletionsToolbarControl` reads mutable `CompleteState` during rendering — this is a snapshot read per render cycle, matching Python's behavior."
- [x] CHK056 - Does the spec address Constitution Principle XI (Thread Safety) for `CompletionsToolbarControl.CreateContent()` reading `AppContext.GetApp().CurrentBuffer.CompleteState` which could change mid-render? [Constitution XI, Gap] — **Resolved**: Constitution Compliance section, Principle XI entry: "No new mutable state is introduced. Toolbar classes store readonly references set at construction. `CompletionsToolbarControl` is stateless — all data is read from `AppContext` at render time. Existing types (`Buffer`, `CompletionState`) are already thread-safe."
- [x] CHK057 - Does the spec address Constitution Principle X (File Size Limits) with explicit LOC estimates per file? The plan has estimates but the spec doesn't. [Constitution X, Gap] — **Resolved**: Constitution Compliance section, Principle X entry: "All files estimated under 200 LOC (largest: SystemToolbar ~180 LOC)."
- [x] CHK058 - Does the spec address Constitution Principle I (Faithful Port) for the `FormattedTextToolbar` `**kw` omission? If kwargs forwarding is intentionally dropped, is the deviation documented with rationale? [Constitution I, Spec §FR-001] — **Resolved**: FR-001 now includes explicit deviation documentation. Constitution Compliance section, Principle I entry documents the deviation. Data model updated with full rationale.
- [x] CHK059 - Does the spec address Constitution Principle VIII (Real-World Testing) by specifying that tests use real `Buffer`, `Layout`, `AppContext` instances (not mocks)? [Constitution VIII, Spec §SC-007] — **Resolved**: SC-007 now specifies "Tests MUST use real `Buffer`, `Layout`, `AppContext` instances per Constitution VIII (no mocks, no fakes, no test doubles)". Constitution Compliance section, Principle VIII entry confirms this.
- [x] CHK060 - Does the spec reference Constitution Principle IX (Adherence to Planning Documents) by confirming the toolbar classes match `api-mapping.md` §widgets entries? [Constitution IX, Spec §Dependencies] — **Resolved**: Constitution Compliance section, Principle IX entry: "Toolbar class names confirmed against `docs/api-mapping.md` section 'widgets' (ArgToolbar, CompletionsToolbar, FormattedTextToolbar, SearchToolbar, SystemToolbar, ValidationToolbar)."

## Integration Risk & Dependencies

- [x] CHK061 - Is the `BufferNames.System` constant verified to exist in the codebase? The data model references it but no verification is documented. [Dependency, Data Model §SystemToolbar] — **Resolved**: Assumptions section now includes: "*(Verified: `src/Stroke/KeyBinding/BufferNames.cs`, value `\"SYSTEM_BUFFER\"`)*". Dependencies section lists BufferNames.
- [x] CHK062 - Is the `AnyContainer` → `IMagicContainer` implicit conversion verified? The spec assumes `AnyContainer` accepts `IMagicContainer` but this is the first usage of the interface. [Dependency, Assumption] — **Resolved**: Assumptions section now documents: "*(Verified: explicit constructor exists in `AnyContainer.cs`)*. Note: C# does not allow implicit conversions from interfaces — use `new AnyContainer(magicContainer)` or `AnyContainer.From(magicContainer)`."
- [x] CHK063 - Is the `SearchBufferControl` constructor signature verified to accept `(buffer, inputProcessors, lexer, ignoreCase)` in that form? [Dependency, Data Model §SearchToolbar] — **Resolved**: Assumptions section documents the actual constructor signature and the integration gap: SearchBufferControl does NOT accept inputProcessors. Resolution documented: extend constructor to forward the existing BufferControl parameter. RT-09 added to research.md. Data model updated with gap description. In Scope section includes the minor extension.
- [x] CHK064 - Are all 4 `AppFilters.HasFocus` overloads verified to exist? SystemToolbar uses `HasFocus(Buffer)` and `HasFocus(Window)` variants. [Dependency, Spec §Assumptions] — **Resolved**: Assumptions section documents: "*(Verified: 4 overloads in `AppFilters.cs`)*. Note: no `HasFocus(Window)` overload — `HasFocus(IContainer)` is used since `Window` implements `IContainer`."
- [x] CHK065 - Is the `Application.ViState` property access path verified for the SystemToolbar Vi bindings? Python accesses `event.app.vi_state.input_mode`. [Dependency, Python L148, L155, L176] — **Resolved**: Assumptions section documents: "*(Verified: pattern used in `ViBindings.ModeSwitch.cs` as `@event.GetApp().ViState.InputMode`)*".
- [x] CHK066 - Is the `KeyPressEvent.App` property (or equivalent access to Application from handler) verified? All SystemToolbar handlers use `event.app`. [Dependency, Python L128, L133] — **Resolved**: Assumptions section documents: "*(Verified: `KeyPressEventExtensions.cs`)*" noting it's an extension method `GetApp()`, not a direct property. Dependencies section includes `KeyPressEventExtensions`.
- [x] CHK067 - Are the assumptions in the spec's Assumptions section independently verified against the actual codebase state, or are they taken on faith? [Traceability, Spec §Assumptions] — **Resolved**: Every assumption now includes a verification status with source file reference (e.g., "*(Verified: exists in `AppFilters.cs` as `IFilter` properties)*").
- [x] CHK068 - Does the spec document the risk that `Application.RunSystemCommandAsync` may not be fully implemented yet, given it's listed as an assumption? [Assumption, Spec §Assumptions] — **Resolved**: Assumptions section now includes the full verified method signature: "*(Verified: exists in `Application.Lifecycle.cs` with signature `(string command, bool waitForEnter = true, AnyFormattedText displayBeforeText = default, string waitText = "Press ENTER to continue...")`)*".

## Notes

- All 68 items reviewed and resolved on 2026-02-01
- Primary artifacts updated: spec.md (comprehensive rewrite), contracts/toolbar-widgets.md (5 edits), data-model.md (6 edits), research.md (RT-09 added)
- Key finding: SearchBufferControl integration gap (RT-09) — constructor needs inputProcessors parameter
- Key finding: AnyContainer has no implicit conversion from IMagicContainer — explicit constructor required
- Key finding: HasFocus has no Window overload — use HasFocus(IContainer) since Window : IContainer
- Python line references are to `/Users/brandon/src/python-prompt-toolkit/src/prompt_toolkit/widgets/toolbars.py`
