# API Fidelity & Cross-Artifact Consistency Checklist: Emacs Key Bindings

**Purpose**: Deep/exhaustive validation that (a) requirements faithfully capture every binding from the Python source, and (b) spec, plan, contracts, and data-model are internally consistent
**Created**: 2026-01-31
**Completed**: 2026-01-31
**Feature**: [spec.md](../spec.md)

## Requirement Completeness — Core Bindings vs Python Source

- [x] CHK001 - Are all 11 movement bindings from the Python source (Ctrl-A, Ctrl-B, Ctrl-E, Ctrl-F, Ctrl-N, Ctrl-P, Ctrl-Left, Ctrl-Right, Meta-b, Meta-f, Ctrl-Home, Ctrl-End) individually enumerated in the spec? [Completeness, Spec §FR-005] — **Resolved**: FR-005 now individually enumerates all 12 movement keys (including Ctrl-N and Ctrl-P as inline handlers) with their exact filters.
- [x] CHK002 - Does FR-005 specify the `Ctrl-D` binding (delete-char) or is it only listed in FR-007? Python line 71 does not register `Ctrl-D` in `load_emacs_bindings` — is Ctrl-D actually a basic binding (from `BasicBindings`) rather than an Emacs binding? [Accuracy, Spec §FR-007 vs Python source] — **Resolved**: Ctrl-D removed from FR-007 with explicit note that it is a basic binding from `BasicBindings`, not registered in `load_emacs_bindings()`.
- [x] CHK003 - Does FR-006 list `Ctrl-K (kill-line)` and `Ctrl-U (backward-kill-line)`, but neither appears in the Python `load_emacs_bindings()` function — are these actually basic bindings from `basic.py` rather than Emacs bindings? [Accuracy, Spec §FR-006 vs Python source] — **Resolved**: Ctrl-K and Ctrl-U removed from FR-006 with explicit note that they are basic bindings from `BasicBindings`. US-2 scenarios updated to remove references to these bindings.
- [x] CHK004 - Is the `Ctrl-W (kill-region with selection)` binding from FR-006 correctly categorized? In the Python source it appears as `_cut` (line 262-269) under selection operations, not kill ring. [Consistency, Spec §FR-006 vs §FR-010] — **Resolved**: Ctrl-W moved from FR-006 to FR-010 (selection operations) where it belongs, with filter: has_selection.
- [x] CHK005 - Are all 9 kill/yank named command bindings from the Python source (Ctrl-Delete, Ctrl-Y, Ctrl-X r y, Escape-d, Escape-Backspace, Escape-y, Escape-\\) each specified with correct key sequences? [Completeness, Contract §Named Command Bindings] — **Resolved**: FR-006 now lists all 7 kill/yank named command bindings with exact key sequences and filters. (Count is 7, not 9 — the original checklist count included Ctrl-K and Ctrl-U which are basic bindings.)
- [x] CHK006 - Are the 3 editing operations from Python source (Escape-c capitalize-word, Escape-l downcase-word, Escape-u uppercase-word) specified with the `insert_mode` filter? [Completeness, Spec §FR-007] — **Resolved**: FR-007 now specifies Meta-c, Meta-l, Meta-u each with explicit `filter: insert_mode`.
- [x] CHK007 - Are the 2 undo bindings (Ctrl-_, Ctrl-X Ctrl-U) specified with both `insert_mode` filter AND `save_before: false`? [Completeness, Spec §FR-007, §FR-026] — **Resolved**: FR-007 now specifies both undo bindings with `filter: insert_mode, save_before: false`. FR-026 explains why save_before: false is needed.
- [x] CHK008 - Are all 6 history bindings from Python source (Escape-<, Escape->, Escape-., Escape-_, Escape-Ctrl-Y, Escape-#, Ctrl-O) specified with their correct filters (`~has_selection` for history nav, `insert_mode` for others)? [Completeness, Spec §FR-008] — **Resolved**: FR-008 now specifies all 7 history bindings (was 6 in checklist, actually 7 including Ctrl-O) with exact per-binding filters: `~has_selection` for Meta-</>  and `insert_mode` for Meta-./\_/Ctrl-Y/#, and `no filter` for Ctrl-O.
- [x] CHK009 - Are the 3 macro bindings (Ctrl-X (, Ctrl-X ), Ctrl-X e) specified without any filter (matching Python source which has no filter)? [Accuracy, Spec §FR-009] — **Resolved**: FR-009 now explicitly states `no filter` for all three macro bindings.
- [x] CHK010 - Is the `Ctrl-Q (quoted-insert)` binding specified with the `~has_selection` filter matching the Python source? [Accuracy, Spec §FR-009 vs Python line 111] — **Resolved**: FR-009 now specifies Ctrl-Q with `filter: ~has_selection` and explicitly notes "NOT insert_mode" to prevent confusion.
- [x] CHK011 - Are all 5 selection operations (Ctrl-@, Ctrl-G×2, Ctrl-W, Ctrl-X r k, Escape-w) specified with their correct filter conditions (`has_selection` or `~has_selection`)? [Completeness, Spec §FR-010] — **Resolved**: FR-010 now lists all 6 selection operation registrations with explicit per-binding filter conditions.
- [x] CHK012 - Are the Meta-Left and Meta-Right word navigation bindings (Python lines 279-298) specified separately from Ctrl-Left/Ctrl-Right? They use `find_previous_word_beginning`/`find_next_word_beginning` (inline handlers), not the `backward-word`/`forward-word` named commands. [Clarity, Spec §FR-011 vs Python source] — **Resolved**: FR-011 now explicitly describes Meta-Left and Meta-Right as inline handlers using `FindPreviousWordBeginning()`/`FindNextWordBeginning()`, noting they are distinct from Ctrl-Left/Right which use named commands.
- [x] CHK013 - Is the `Enter` accept-line binding specified with the composite filter `insert_mode & is_returnable & ~is_multiline`, exactly matching Python line 161? [Accuracy, Spec §FR-012] — **Resolved**: FR-012 now specifies Enter with exact filter composition `insert_mode & is_returnable & ~is_multiline` and notes "all three conditions required".
- [x] CHK014 - Is the `Meta-Enter` accept-line binding specified with the composite filter `insert_mode & is_returnable`, exactly matching Python line 156? [Accuracy, Spec §FR-012] — **Resolved**: FR-012 now specifies Meta-Enter with `filter: insert_mode & is_returnable` (insert_mode was previously missing).
- [x] CHK015 - Are the 2 character search bindings (Ctrl-] + Any, Escape Ctrl-] + Any) specified as multi-key sequences with `Keys.Any` as the final key? [Completeness, Spec §FR-013] — **Resolved**: FR-013 specifies both character search bindings as multi-key sequences with inline handler details and `Document.Find`/`FindBackwards` with `inCurrentLine: true`.
- [x] CHK016 - Are all 22 numeric argument bindings (10 × Escape-digit, 10 × digit-with-has_arg, Escape-dash, dash-when-is_arg) specified? [Completeness, Spec §FR-014] — **Resolved**: FR-014 now specifies all 22 bindings: Meta-0-9 (no filter), digits 0-9 (filter: has_arg), Meta-- (filter: ~has_arg), dash (filter: is_arg).
- [x] CHK017 - Is the `Escape` silent-consume binding specified with no filter, matching Python line 57? [Accuracy, Spec §FR-015] — **Resolved**: FR-015 specifies Escape as a no-op handler with no filter, registered first in the binding list.
- [x] CHK018 - Are the 3 placeholder bindings (Meta-a, Meta-e, Meta-t) specified as no-op handlers matching Python's TODO comments? [Completeness, Spec §FR-016] — **Resolved**: FR-016 specifies all three as placeholder no-op handlers with per-binding filters (Meta-a/e: no filter, Meta-t: insert_mode), matching Python TODO comments.
- [x] CHK019 - Is the `Meta-* (insert-all-completions)` inline handler specified with the `insert_mode` filter? [Accuracy, Spec §FR-009] — **Resolved**: FR-009 specifies Meta-* with `filter: insert_mode` as an inline handler.
- [x] CHK020 - Is the `Ctrl-X Ctrl-X (toggle start/end)` binding specified without any filter, matching Python line 222? [Accuracy, Spec §FR-011] — **Resolved**: FR-011 specifies Ctrl-X Ctrl-X as an inline handler with `no filter`.
- [x] CHK021 - Are the Ctrl-C > and Ctrl-C < (indent/unindent) bindings specified with the `has_selection` filter? [Accuracy, Spec §FR-011] — **Resolved**: FR-011 specifies Ctrl-C > and Ctrl-C < with `filter: has_selection`.
- [x] CHK022 - Is the `Meta-/ (complete)` binding specified with the `insert_mode` filter and its dual behavior (start if no completion, cycle if active)? [Completeness, Spec §FR-009] — **Resolved**: FR-009 specifies Meta-/ with `filter: insert_mode` and documents dual behavior: starts with `select_first=true` if not active, cycles with `complete_next()` if active.

## Requirement Completeness — Search Bindings vs Python Source

- [x] CHK023 - Does FR-017 enumerate all 11 search binding registrations from Python `load_emacs_search_bindings()` (Ctrl-R×2, Ctrl-S×2, Ctrl-C, Ctrl-G, Enter, Escape-eager, Up, Down)? [Completeness, Spec §FR-017] — **Resolved**: FR-017 now enumerates all 10 registrations with descriptions (Ctrl-R×2, Ctrl-S×2, Ctrl-C, Ctrl-G, Enter, Escape-eager, Up, Down). Count is 10 not 11.
- [x] CHK024 - Does FR-018 specify all 6 read-only mode search bindings (/, ?, /reversed, ?reversed, n, N) with their filter compositions? [Completeness, Spec §FR-018] — **Resolved**: FR-018 specifies all 6 read-only mode bindings with exact filter compositions including `vi_search_direction_reversed` inversion.
- [x] CHK025 - Is it specified that the Escape binding in search mode uses `eager=True`, matching Python line 365? [Clarity, Spec §FR-017] — **Resolved**: FR-017 explicitly states Escape uses `eager=true` flag and notes it "accepts rather than aborts, matching Readline convention".
- [x] CHK026 - Does the spec acknowledge that `LoadEmacsSearchBindings()` is already implemented in `SearchBindings` rather than `EmacsBindings`? [Clarity, Spec §FR-002 vs §FR-004] — **Resolved**: FR-002 notes it is already implemented in `SearchBindings` per api-mapping.md. FR-004 states only two loaders are on `EmacsBindings`. US-4 adds a Note about SearchBindings.

## Requirement Completeness — Shift Selection Bindings vs Python Source

- [x] CHK027 - Are all 10 shift-start keys (ShiftLeft/Right/Up/Down/Home/End, CtrlShiftLeft/Right/Home/End) individually listed for the start-selection handler? [Completeness, Spec §FR-019] — **Resolved**: FR-019 individually lists all 10 keys.
- [x] CHK028 - Are the same 10 shift keys listed for the extend-selection handler? [Completeness, Spec §FR-020] — **Resolved**: FR-020 references "the same 10 Shift+movement keys" with filter: shift_selection_mode.
- [x] CHK029 - Are all 10 cancel-movement keys (Left/Right/Up/Down/Home/End, CtrlLeft/Right/Home/End) individually listed for the cancel handler? [Completeness, Spec §FR-021] — **Resolved**: FR-021 individually lists all 10 non-shift movement keys.
- [x] CHK030 - Is the `Keys.Any` binding for replace-selection specified with the `shift_selection_mode` filter? [Accuracy, Spec §FR-022] — **Resolved**: FR-022 specifies `Keys.Any` with `filter: shift_selection_mode`.
- [x] CHK031 - Is the `Enter` shift-selection binding specified with the composite filter `shift_selection_mode & is_multiline`? [Accuracy, Spec §FR-023] — **Resolved**: FR-023 specifies Enter with `filter: shift_selection_mode & is_multiline`.
- [x] CHK032 - Is it specified that the shift-selection `_yank` handler checks `buff.selection_state` before cutting (conditional cut, not always cut), matching Python line 539? [Clarity, Spec §FR-023 vs Python source] — **Resolved**: FR-023 specifies Ctrl-Y "conditionally cut selection only if `selection_state` is non-null".
- [x] CHK033 - Is the empty-selection cancellation logic (cursor doesn't move after shift-start → cancel selection) specified in FR-024? [Completeness, Spec §FR-024] — **Resolved**: FR-024 specifies the handler compares `cursor_position` before and after `unshift_move` and calls `exit_selection()` if unchanged.
- [x] CHK034 - Is the empty-selection-on-extend logic (cursor returns to original position → cancel selection) specified? Python lines 505-508 are not explicitly called out in the spec. [Gap, Spec §FR-020] — **Resolved**: FR-020 now specifies that if `cursor_position == selection_state.original_cursor_position` after extending, the selection MUST be cancelled via `exit_selection()`.
- [x] CHK035 - Is the `in_paste_mode` filter usage in the shift-selection newline handler (Python line 524: `copy_margin=not in_paste_mode()`) specified in the requirements? [Gap, Spec §FR-023] — **Resolved**: FR-023 specifies `buffer.newline(copy_margin: !in_paste_mode())` and notes this matches Python source line 524.
- [x] CHK036 - Is the re-feed behavior of the cancel handler (`key_processor.feed(key_press, first=True)`) specified in FR-021? [Completeness, Spec §FR-021] — **Resolved**: FR-021 specifies "re-process the key press via `KeyProcessor.Feed(keyPress, first: true)` so the movement still executes".

## Requirement Clarity

- [x] CHK037 - Is the distinction between `emacs_mode` (outer ConditionalKeyBindings wrapper) and `emacs_insert_mode` (per-binding filter for text-modifying operations) clearly defined? [Clarity, Spec §FR-025] — **Resolved**: FR-025 explicitly defines the distinction and Key Entities section has a dedicated "emacs_mode vs emacs_insert_mode" entry.
- [x] CHK038 - Is `emacs_insert_mode` defined unambiguously as "Emacs mode AND no selection AND not read-only"? [Clarity, Spec §Key Entities] — **Resolved**: FR-025 defines `emacs_insert_mode` as `emacs_mode & ~is_read_only & ~has_selection`. Key Entities repeats this definition.
- [x] CHK039 - Is the `is_returnable` condition defined with enough precision (checks `buffer.is_returnable`, not `buffer.accept_handler`)? [Clarity, Spec §FR-012] — **Resolved**: Key Entities defines `is_returnable` as "checking `AppContext.GetApp().CurrentBuffer.IsReturnable` — distinct from checking `accept_handler`".
- [x] CHK040 - Is the `is_arg` condition defined precisely as `key_processor.arg == "-"` (string equality, not boolean check)? [Clarity, Spec §FR-014] — **Resolved**: Key Entities defines `is_arg` as `KeyProcessor.Arg == "-"` (string equality comparison). FR-014 also specifies this.
- [x] CHK041 - Is the difference between `has_arg` (any argument is active) and `is_arg` (argument is specifically "-") clearly documented? [Clarity, Spec §FR-014] — **Resolved**: Key Entities explicitly states `is_arg` is "Distinct from `has_arg` which checks if any argument is active (non-null)".
- [x] CHK042 - Is "placeholder" for Meta-a/e/t specified clearly enough — do they register as no-op handlers (match Python's TODO with `pass`), not as omitted bindings? [Clarity, Spec §FR-016] — **Resolved**: FR-016 specifies "placeholder no-op handlers" with "empty handler bodies" matching "Python source TODO comments".
- [x] CHK043 - Are the terms "kill ring", "yank", and "clipboard" used consistently? The spec uses both "clipboard" and "kill ring" — is the relationship between them defined? [Clarity, Spec §US-2] — **Resolved**: Key Entities adds "Kill ring and clipboard" entry: "The Emacs 'kill ring' is backed by the application's `IClipboard` interface. Kill operations place data on the clipboard; yank operations retrieve from it."
- [x] CHK044 - Is `save_before: false` behavior explained (prevents undo snapshot before undo operation itself)? [Clarity, Spec §FR-026] — **Resolved**: FR-026 explains "to prevent the undo system from saving state before the undo operation itself, which would create an unwanted undo snapshot".

## Requirement Consistency — Spec vs Contract

- [x] CHK045 - Does the contract's binding inventory (68 core + 34 shift) account for all bindings listed in FR-005 through FR-016? [Consistency, Contract vs Spec] — **Resolved**: FR-028 now specifies the authoritative total: 78 core (35 named + 43 inline) + 34 shift = 112 total. The contract's count of ~68 undercounted inline handlers. Spec is now the source of truth.
- [x] CHK046 - Does the contract correctly show Ctrl-K and Ctrl-U as NOT present (since they appear to be basic bindings, not Emacs bindings)? Or does FR-006 require them? [Conflict, Spec §FR-006 vs Contract vs Python source] — **Resolved**: FR-006 now explicitly excludes Ctrl-K and Ctrl-U with a Note explaining they are basic bindings. Conflict eliminated.
- [x] CHK047 - Does the contract show `Ctrl-D (delete-char)` as NOT present (since it's a basic binding)? Or does FR-007 require it? [Conflict, Spec §FR-007 vs Contract vs Python source] — **Resolved**: FR-007 now explicitly excludes Ctrl-D with a Note explaining it is a basic binding. Conflict eliminated.
- [x] CHK048 - Is the contract's filter column consistent with the spec's filter requirements (FR-025 through FR-027)? [Consistency, Contract §Named Command Bindings vs Spec §FR-025-027] — **Resolved**: FR-005 through FR-014 now specify per-binding filters explicitly. FR-025-027 provide general rules. The spec is now authoritative and the contract must conform.
- [x] CHK049 - Does the contract's handler name `CutSelectionHandler` match the data-model's handler name `CutSelection`? [Consistency, Contract §Inline Handlers vs Data-Model §Inline Handlers] — **Resolved**: Key Entities Inline Handlers section now uses `CutSelection` as the canonical name. Contract and data-model will be updated to match.
- [x] CHK050 - Does the contract's handler name `CopySelectionHandler` match the data-model's handler name `CopySelection`? [Consistency, Contract §Inline Handlers vs Data-Model §Inline Handlers] — **Resolved**: Key Entities uses `CopySelection` as the canonical name.
- [x] CHK051 - Does the contract's handler name `CompleteHandler` match the data-model's handler name `Complete`? [Consistency, Contract §Inline Handlers vs Data-Model §Inline Handlers] — **Resolved**: Key Entities uses `Complete` as the canonical name.

## Requirement Consistency — Spec vs Plan

- [x] CHK052 - Does the plan state `LoadEmacsSearchBindings()` is in `SearchBindings`, but spec FR-004 says "all three binding loader methods MUST be static methods on a single `EmacsBindings` class"? Is this a conflict? [Conflict, Spec §FR-004 vs Plan §Summary] — **Resolved**: FR-004 rewritten to state only two loaders on `EmacsBindings`. FR-002 explicitly notes LoadEmacsSearchBindings is on SearchBindings. Conflict eliminated.
- [x] CHK053 - Does the plan's file split (`EmacsBindings.cs` ~600-700 LOC, `EmacsBindings.ShiftSelection.cs` ~300-400 LOC) align with the Constitution X limit of 1,000 LOC? [Consistency, Plan §Project Structure vs Constitution §X] — **Resolved**: Both files are within 1,000 LOC limit. This is a plan-level concern (not spec) and was already correct.
- [x] CHK054 - Does the plan's test file structure match the test-mapping.md requirement for `EmacsModeTests.cs`? [Consistency, Plan §Project Structure vs test-mapping.md] — **Resolved**: Plan-level concern. The plan includes `EmacsModeTests.cs` alongside granular test files. No spec change needed.
- [x] CHK055 - Does the plan correctly identify that the API mapping (line 1343) places `LoadEmacsSearchBindings()` on `SearchBindings`, not `EmacsBindings`? [Consistency, Plan §Constitution Check IX vs api-mapping.md] — **Resolved**: FR-002 and FR-004 now explicitly reference this. The plan's constitution check correctly identifies this.

## Requirement Consistency — Spec vs Data-Model

- [x] CHK056 - Does the data-model's inline handler table (24 handlers) account for every inline binding in the spec? [Consistency, Data-Model §Inline Handlers vs Spec §FR-005-016] — **Resolved**: Key Entities now provides an authoritative canonical list of all inline handlers organized by category. The data-model's handler count will be updated to match.
- [x] CHK057 - Does the data-model's shift-selection state machine cover all 7 state transitions described in the spec (start, extend, cancel-move, replace, newline, delete, yank)? [Consistency, Data-Model §State Transitions vs Spec §FR-019-024] — **Resolved**: FR-019-024 fully specify all 7 state transitions. The data-model's state machine diagram must match.
- [x] CHK058 - Are the data-model's validation rules consistent with the spec's filter requirements? [Consistency, Data-Model §Validation Rules vs Spec §FR-025-027] — **Resolved**: FR-025-027 now provide detailed filter rules. FR-025 defines emacs_mode vs emacs_insert_mode distinction.
- [x] CHK059 - Does the data-model's `IsArg` filter definition (`KeyProcessor.Arg == "-"`) match the spec's FR-014 description? [Consistency, Data-Model §Module-Level Filters vs Spec §FR-014] — **Resolved**: FR-014 and Key Entities both specify `KeyProcessor.Arg == "-"`. Consistent.

## Acceptance Criteria Quality

- [x] CHK060 - Are acceptance scenarios for User Story 1 (movement) specific about cursor positions? Some scenarios reference exact positions while others use relative descriptions. [Measurability, Spec §US-1] — **Resolved**: US-1 scenarios now have specific positions (scenario 2: "position 11", scenario 5: "position 0"). Added scenarios 9-10 for Ctrl-N/Ctrl-P with behavior details.
- [x] CHK061 - Does User Story 2 (kill ring) have an acceptance scenario for `yank-pop` cycling beyond the first replacement? [Coverage, Spec §US-2] — **Resolved**: US-2 scenario 4 added for repeated Meta-y cycling (wrapping if needed).
- [x] CHK062 - Does User Story 3 (selection) have an acceptance scenario for `Ctrl-X r k` (alternative cut sequence)? [Coverage, Spec §US-3] — **Resolved**: US-3 scenario 6 added for Ctrl-X r k cut behavior.
- [x] CHK063 - Does User Story 4 (search) have an acceptance scenario for `Ctrl-C` abort (in addition to `Ctrl-G`)? [Coverage, Spec §US-4] — **Resolved**: US-4 scenario 7 added for Ctrl-C abort. Scenario 8 added for Escape accept (eager=true).
- [x] CHK064 - Does User Story 5 (shift selection) have an acceptance scenario for `Ctrl-Shift-Left/Right` (word-level shift selection)? [Coverage, Spec §US-5] — **Resolved**: US-5 scenario 8 added for Ctrl-Shift-Left word-level shift selection.
- [x] CHK065 - Does User Story 6 (numeric args) have an acceptance scenario for negative arguments applied to a command (e.g., Meta-- Meta-3 Ctrl-F → backward 3)? [Coverage, Spec §US-6] — **Resolved**: US-6 scenario 6 added for negative argument applied to Ctrl-F (backward 3 characters).
- [x] CHK066 - Does User Story 7 (macros) have an acceptance scenario for recording a macro that includes named commands (not just text insertion)? [Coverage, Spec §US-7] — **Resolved**: US-7 scenario 5 added for macro recording that includes Ctrl-A (named command replay).
- [x] CHK067 - Does User Story 8 (history) have an acceptance scenario for `Ctrl-O (operate-and-get-next)` beyond the description in FR-008? [Coverage, Spec §US-8] — **Resolved**: US-8 scenario 7 added for Ctrl-O boundary handling on last history entry.
- [x] CHK068 - Does User Story 9 (completion) have an acceptance scenario for `Ctrl-Q (quoted insert)` behavior? [Coverage, Spec §US-9] — **Resolved**: US-9 scenario 8 added for Ctrl-Q quoted insert behavior.
- [x] CHK069 - Are success criteria SC-001 through SC-006 each independently measurable without reference to implementation details? [Measurability, Spec §SC] — **Resolved**: SC-001 through SC-006 are measurable by comparing against Python source, counting registrations, testing mode conditions, measuring coverage, running state transition tests, and verifying argument handling. SC-005 updated with specific transition names.
- [x] CHK070 - Can SC-002 ("100% of approximately 80+ individual keybindings") be precisely measured — is the exact count defined somewhere? [Measurability, Spec §SC-002] — **Resolved**: SC-002 now specifies exact count: "All 112 individual binding registrations (78 in LoadEmacsBindings + 34 in LoadEmacsShiftSelectionBindings)". FR-028 also provides breakdown (35 named + 43 inline = 78, plus 34 shift).

## Scenario Coverage — Edge Cases

- [x] CHK071 - Is the edge case for empty buffer + kill operations (spec §Edge Cases item 1) addressed by a specific FR or acceptance scenario? [Coverage, Spec §Edge Cases] — **Resolved**: Edge case 1 states "Movement commands should be no-ops; kill operations should not error." US-3 scenario 7 and US-5 scenario 7 also cover empty buffer.
- [x] CHK072 - Is the edge case for `Meta-y` without preceding `Ctrl-Y` (spec §Edge Cases item 3) addressed by a specific FR or acceptance scenario? [Coverage, Spec §Edge Cases] — **Resolved**: Edge case 3 specifies behavior follows named command implementation.
- [x] CHK073 - Is the edge case for very large numeric arguments (spec §Edge Cases item 4) addressed by the `MaxArgValue` clamping in `KeyPressEvent`? Is this documented in the spec? [Coverage, Spec §Edge Cases] — **Resolved**: Edge case 4 now specifies "`KeyPressEvent.AppendToArgCount` has clamping".
- [x] CHK074 - Is the edge case for Ctrl-] with no matching character (spec §Edge Cases item 5) addressed by the `CharacterSearch` handler returning without moving? [Coverage, Spec §Edge Cases] — **Resolved**: Edge case 5 now specifies "The `character_search` helper returns without moving the cursor (the `Document.Find()` result is null)".
- [x] CHK075 - Is the edge case for concurrent Ctrl-Space and shift-selection (spec §Edge Cases item 7) adequately specified? The statement "shift-selection mode has its own filter and takes precedence" needs more precision. [Clarity, Spec §Edge Cases] — **Resolved**: Edge case 7 now explains the filter distinction: shift-selection uses `shift_selection_mode` (checks `SelectionState.ShiftMode`), Ctrl-Space uses `has_selection`. Shift-selection bindings only activate for shift-initiated selections.
- [x] CHK076 - Is there an edge case for `Meta-*` (insert-all-completions) when no completer is configured or completer returns zero completions? [Gap] — **Resolved**: New edge case added for Meta-* with no completer (raises error) and zero completions (inserts empty string).
- [x] CHK077 - Is there an edge case for the indent/unindent handler when the selection spans zero lines or is on a single line? [Gap] — **Resolved**: New edge case added for indent/unindent on single-line selection.
- [x] CHK078 - Is there an edge case for `Ctrl-X Ctrl-X` (toggle start/end) when the cursor is already at the start of the line? [Gap] — **Resolved**: New edge case added for Ctrl-X Ctrl-X at start of line.

## Dependency & Assumption Quality

- [x] CHK079 - Are all 7 assumptions (NamedCommands, filters, search ops, KeyBindings, Buffer methods, SelectionState, BufferOperations) validated against actually-implemented features? [Assumption, Spec §Assumptions] — **Resolved**: All 7 original assumptions validated and expanded to 15 total assumptions with specific method signatures.
- [x] CHK080 - Is the assumption about `Buffer.indent/unindent` verified against the actual `BufferOperations.Indent/Unindent` static methods in Core? [Assumption, Spec §Assumptions item 7] — **Resolved**: Assumption now specifies `BufferOperations.Indent(Buffer, int fromRow, int toRow, int count)` and `BufferOperations.Unindent(...)` — verified against actual codebase.
- [x] CHK081 - Is the assumption about `SelectionState.enter_shift_mode()` verified — does the method name match (`EnterShiftMode()` in C#)? [Assumption, Spec §Assumptions item 6] — **Resolved**: Assumption uses `EnterShiftMode()` (PascalCase). Verified `EnterShiftMode` exists in `SelectionState.cs`.
- [x] CHK082 - Are all named commands referenced in the contract (beginning-of-line, kill-word, yank, etc.) verified as registered in NamedCommands from Feature 034? [Dependency, Contract §Named Command Bindings] — **Resolved**: Assumption 1 lists specific named commands and references Feature 034. All are registered.
- [x] CHK083 - Is the dependency on `CompleteEvent` and `ICompleter` (for `Meta-*`) documented in the spec's assumptions? [Gap, Spec §Assumptions] — **Resolved**: New assumption added: "`CompleteEvent` record and `ICompleter` interface are available from Feature 012 (Stroke.Completion)".
- [x] CHK084 - Is the dependency on `KeyPressEvent.AppendToArgCount()` and `KeyPressEvent.ArgPresent` documented? [Gap, Spec §Assumptions] — **Resolved**: New assumption added: "`KeyPressEvent.AppendToArgCount(string)` and `KeyPressEvent.ArgPresent` (or `_arg` equivalent) are available from Feature 022".
- [x] CHK085 - Is the dependency on `KeyProcessor.Feed()` and `KeyProcessor.Arg` setter documented? [Gap, Spec §Assumptions] — **Resolved**: New assumption added: "`KeyProcessor.Feed(KeyPress, bool first)` is available for shift-selection cancel-move re-feed behavior; `KeyProcessor.Arg` setter is available for the dash-when-arg handler".
- [x] CHK086 - Is the dependency on `Buffer.Newline(bool copyMargin)` documented for the shift-selection newline handler? [Gap, Spec §Assumptions] — **Resolved**: `Newline(bool copyMargin)` added to the Buffer methods assumption list.
- [x] CHK087 - Is the dependency on `Document.FindPreviousWordBeginning()` and `Document.FindNextWordBeginning()` for Meta-Left/Right documented? [Gap, Spec §Assumptions] — **Resolved**: New assumption added for `Document.FindPreviousWordBeginning(count)` and `Document.FindNextWordBeginning(count)`.
- [x] CHK088 - Is the dependency on `Document.IsCursorAtTheEndOfLine`, `Document.GetStartOfLinePosition()`, and `Document.GetEndOfLinePosition()` for Ctrl-X Ctrl-X documented? [Gap, Spec §Assumptions] — **Resolved**: New assumption added for all three Document properties/methods.
- [x] CHK089 - Is the dependency on `Document.Find()` and `Document.FindBackwards()` with `inCurrentLine: true` for character search documented? [Gap, Spec §Assumptions] — **Resolved**: New assumption added for `Document.Find(string, bool inCurrentLine, int count)` and `Document.FindBackwards(...)`.
- [x] CHK090 - Is the dependency on `Document.SelectionRange()` and `Document.TranslateIndexToPosition()` for indent/unindent documented? [Gap, Spec §Assumptions] — **Resolved**: New assumption added for `Document.SelectionRange()` and `Document.TranslateIndexToPosition(int index)` with return types.

## Python Source Fidelity — Binding-by-Binding

- [x] CHK091 - Python line 69: `handle("c-a")(get_by_name("beginning-of-line"))` — is this specified with NO filter (not even insert_mode)? [Fidelity, Contract #1] — **Resolved**: FR-005 specifies Ctrl-A with "no filter".
- [x] CHK092 - Python line 70: `handle("c-b")(get_by_name("backward-char"))` — same no-filter check. [Fidelity, Contract #2] — **Resolved**: FR-005 specifies Ctrl-B with "no filter".
- [x] CHK093 - Python line 71: `handle("c-delete", filter=insert_mode)` — is the `insert_mode` filter specified? [Fidelity, Contract #3] — **Resolved**: FR-006 specifies Ctrl-Delete with "filter: insert_mode".
- [x] CHK094 - Python line 76: `handle("c-x", "r", "y", filter=insert_mode)` — is this 3-key sequence specified correctly? [Fidelity, Contract #8] — **Resolved**: FR-006 specifies "Ctrl-X r y (yank, 3-key sequence, filter: insert_mode)".
- [x] CHK095 - Python line 91-93: `handle("c-_", save_before=(lambda e: False), filter=insert_mode)` — are both `save_before: false` AND `insert_mode` specified? [Fidelity, Contract #21] — **Resolved**: FR-007 specifies "Ctrl-_ (undo, filter: insert_mode, save_before: false)".
- [x] CHK096 - Python line 99: `handle("escape", "<", filter=~has_selection)` — is the `~has_selection` (inverted) filter specified? [Fidelity, Contract #23] — **Resolved**: FR-008 specifies "Meta-< (beginning-of-history, filter: ~has_selection)".
- [x] CHK097 - Python line 111: `handle("c-q", filter=~has_selection)` — is the `~has_selection` filter specified (not `insert_mode`)? [Fidelity, Contract #30] — **Resolved**: FR-009 specifies "Ctrl-Q (quoted-insert, filter: ~has_selection — note: NOT insert_mode)".
- [x] CHK098 - Python line 117-120: `@handle("c-n")` with `event.current_buffer.auto_down()` — is this specified as an inline handler (not named command) with NO count argument? [Fidelity, Contract #37] — **Resolved**: FR-005 specifies "Ctrl-N (auto-down, inline handler, no filter, no count argument)". US-1 scenario 9 also documents this.
- [x] CHK099 - Python line 122-125: `@handle("c-p")` with `auto_up(count=event.arg)` — is it specified that `auto_up` receives `count` but `auto_down` does NOT? [Fidelity, Spec §FR-005] — **Resolved**: FR-005 specifies "Ctrl-P (auto-up, inline handler, no filter, receives count=event.arg)" while Ctrl-N says "no count argument". US-1 scenarios 9-10 document the asymmetry.
- [x] CHK100 - Python lines 133-134: digit bindings use both `handle(c, filter=has_arg)` AND `handle("escape", c)` — are both registration patterns specified for each digit? [Fidelity, Contract #39-48] — **Resolved**: FR-014 specifies both patterns: "Meta-0 through Meta-9 (Escape + digit, ... no filter) and plain digits 0-9 (append digit, filter: has_arg)".
- [x] CHK101 - Python line 141-145: `_meta_dash` checks `event._arg is None` — is this requirement specified (must check that no arg exists before setting negative prefix)? [Fidelity, Spec §FR-014] — **Resolved**: FR-014 specifies "MUST check `event._arg is None` before appending '-'".
- [x] CHK102 - Python line 147-153: `_dash` sets `event.app.key_processor.arg = "-"` — is the direct KeyProcessor.Arg setter specified? [Fidelity, Spec §FR-014] — **Resolved**: FR-014 specifies "maintain negative state by directly setting `KeyProcessor.Arg = \"-\"`".
- [x] CHK103 - Python line 365: search binding `handle("escape", eager=True)(search.accept_search)` — is the `eager=True` flag specified in FR-017? [Fidelity, Spec §FR-017] — **Resolved**: FR-017 specifies "Escape with `eager=true` flag (accept search — accepts rather than aborts)".
- [x] CHK104 - Python line 506: extend handler checks `buff.cursor_position == buff.selection_state.original_cursor_position` — is this specific cursor-position comparison specified in the requirements? [Fidelity, Spec §FR-020 vs Gap] — **Resolved**: FR-020 specifies "if the cursor position equals `selection_state.original_cursor_position` (selection becomes empty), the selection MUST be cancelled". Also added as edge case.

## Non-Functional Requirements

- [x] CHK105 - Is thread safety addressed? The class is stateless but are there requirements about the filter conditions being evaluated on different threads? [Coverage, Gap] — **Resolved**: NFR-001 added: "The `EmacsBindings` class MUST be a stateless static class with no mutable fields. It is inherently thread-safe and requires no synchronization."
- [x] CHK106 - Are there requirements about binding registration order within each loader (e.g., Escape must be registered first to prevent character insertion)? [Gap] — **Resolved**: NFR-003 added: "The Escape key binding MUST be registered before other bindings". FR-015 and FR-028 also reference registration order.
- [x] CHK107 - Is there a requirement that each call to `LoadEmacsBindings()` returns a NEW instance (not a cached singleton)? [Coverage, Gap] — **Resolved**: NFR-002 added: "Each call... MUST return a freshly constructed instance (no cached singletons)". FR-001 and FR-003 also state this.

## Notes

- Check items off as completed: `[x]`
- Items marked `[Gap]` indicate missing requirements that were added to the spec
- Items marked `[Conflict]` indicate inconsistencies between artifacts that were resolved
- Items marked `[Fidelity]` validate 1:1 Python source matching
- Items with dual references (e.g., `Spec §FR-006 vs Python source`) indicate cross-reference checks
- All 107 items resolved on 2026-01-31
