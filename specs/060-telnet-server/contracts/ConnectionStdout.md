# Contract: ConnectionStdout

**Namespace**: `Stroke.Contrib.Telnet`
**Python Source**: `prompt_toolkit.contrib.telnet.server._ConnectionStdout`

## Class Signature

```csharp
namespace Stroke.Contrib.Telnet;

/// <summary>
/// TextWriter wrapper for telnet socket output.
/// </summary>
/// <remarks>
/// <para>
/// This is a faithful port of Python Prompt Toolkit's <c>_ConnectionStdout</c> class.
/// It wraps a socket and provides a TextWriter interface compatible with
/// <see cref="Vt100Output"/>.
/// </para>
/// <para>
/// Key behaviors:
/// <list type="bullet">
/// <item>LF → CRLF conversion per telnet NVT specification (FR-006)</item>
/// <item>Buffered writes with explicit flush</item>
/// <item>Silent no-op after close (won't throw on closed socket)</item>
/// </list>
/// </para>
/// <para>
/// Thread safety: This class is thread-safe. Write and Flush operations are
/// synchronized.
/// </para>
/// </remarks>
internal sealed class ConnectionStdout : TextWriter
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ConnectionStdout"/> class.
    /// </summary>
    /// <param name="socket">The socket to write to.</param>
    /// <param name="encoding">The character encoding.</param>
    public ConnectionStdout(Socket socket, Encoding encoding);

    /// <summary>
    /// Gets the character encoding for this writer.
    /// </summary>
    public override Encoding Encoding { get; }

    /// <summary>
    /// Writes a string to the buffer.
    /// </summary>
    /// <param name="value">The string to write.</param>
    /// <remarks>
    /// <para>
    /// Line endings are converted: LF (0x0A) becomes CRLF (0x0D 0x0A).
    /// This is per the telnet Network Virtual Terminal specification.
    /// </para>
    /// <para>
    /// After writing, the buffer is automatically flushed.
    /// </para>
    /// <para>
    /// If the connection is closed, this is a no-op.
    /// </para>
    /// </remarks>
    public override void Write(string? value);

    /// <summary>
    /// Writes a character to the buffer.
    /// </summary>
    /// <param name="value">The character to write.</param>
    public override void Write(char value);

    /// <summary>
    /// Writes characters to the buffer.
    /// </summary>
    /// <param name="buffer">The character buffer.</param>
    /// <param name="index">Start index.</param>
    /// <param name="count">Number of characters.</param>
    public override void Write(char[] buffer, int index, int count);

    /// <summary>
    /// Flushes the buffer to the socket.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Sends all buffered bytes over the socket. After flushing, the buffer
    /// is cleared.
    /// </para>
    /// <para>
    /// Socket errors (e.g., connection reset) are logged but not thrown.
    /// This allows graceful handling of client disconnections.
    /// </para>
    /// </remarks>
    public override void Flush();

    /// <summary>
    /// Marks this writer as closed.
    /// </summary>
    /// <remarks>
    /// After closing, all write operations become no-ops. The underlying
    /// socket is NOT closed by this method (managed by TelnetConnection).
    /// </remarks>
    public void Close();

    /// <summary>
    /// Gets whether this writer has been closed.
    /// </summary>
    public bool IsClosed { get; }

    /// <summary>
    /// Returns whether the underlying stream supports TTY features.
    /// Always returns true for telnet (we pretend to be a TTY).
    /// </summary>
    internal bool IsAtty => true;
}
```

## Functional Requirements Coverage

| Requirement | Method |
|-------------|--------|
| FR-006: LF→CRLF conversion | `Write()` |

## Python API Mapping

| Python | C# |
|--------|-----|
| `__init__(connection, encoding)` | Constructor |
| `encoding` property | `Encoding` |
| `errors` property | (N/A - use Encoding's error handling) |
| `write(data)` | `Write(value)` |
| `flush()` | `Flush()` |
| `close()` | `Close()` |
| `_closed` | `IsClosed` |
| `isatty()` | `IsAtty` |

## Implementation Notes

### LF→CRLF Conversion

The telnet protocol requires that line endings use CRLF (carriage return + line feed). The `Write` method performs this conversion:

```csharp
// Conceptual implementation
value = value?.Replace("\n", "\r\n");
```

Note: This may double-convert existing CRLF sequences to CR-CR-LF. Python Prompt Toolkit has the same behavior. For most use cases this is acceptable since output is typically generated by the application, not echoed from input.

### Error Handling

Socket write errors are caught and logged rather than thrown:

```csharp
try
{
    socket.Send(buffer);
}
catch (SocketException ex)
{
    // Log but don't throw - connection may have been closed
    Logger.LogWarning("Socket write failed: {Error}", ex.Message);
}
```

This prevents exceptions when clients disconnect unexpectedly.
